#计算机组成原理 #应试笔记与八股 

## 目录

```toc
```

## 1.1 计算机系统层次结构

### 1.1.1 计算机系统的组成

计算机系统的组成：
	计算机系统是由硬件系统和软件系统组成。

### 1.1.2  计算机硬件

冯诺依曼架构：
	冯诺依曼体系的基本思想是<font color="#c00000">将程序指令存储和数据一起存储在计算机的内存中</font>，<span style="background:#fff88f"><font color="#c00000">首次提出了"存储程序"的概念</font></span>，其主要由如下几个部件构成：
	1. 输入设备
	2. 输出设备
	3. 存储器，可分为主存储器(内存)和辅存储器(外存)
	4. 运算器，运算器和控制器可一起简化为CPU
	5. 控制器
	其基本结构如下：(主要用于了解结构体系)
		![[Pasted image 20240329180301.png]]
	上述五个主要部分可如下划分归类：(需要注意主机的概念)
		![[Pasted image 20240329172539.png]]
	冯诺依曼体系的特点有：
	1. 指令和数据以同等地位存储并可以按地址访问
	2. 数据和指令均以二进制表示
	3. 指令由操作码和地址码(运算数的地址)组成
	4. 会提前将指令和数据存储到存储器中
	5. <font color="#c00000">冯诺依曼结构以运算器为核心</font>，<font color="#c00000">现代计算机以存储器为中心</font>。

主存储器的基本组成：
	其由存储体、MAR(存储地址寄存器)、MDR(存储数据寄存器)组成，其主要基本结构如下图所示：
	![[Pasted image 20240329173142.png]]
	其中：
		MAR为存储地址寄存器，用于存放访存地址，其长度一般与PC的长度相等，其长度可以决定存储体中存储单元个数的上限。
		MDR为存储数据寄存器，用于暂存要读写的信息，其长度与存储字长相等，一般为2的幂的整数倍。
		<font color="#c00000">在现代计算机中，MAR和MDR一般集成于CPU内部</font>。
	在主存储器中还有以下基础概念：
		<font color="#9bbb59">存储单元</font>：存储单元是每个存储体以寻址方式进行划分的最小单元。
		<font color="#9bbb59">存储字</font>：是存储器存储和处理数据的最小单位，<span style="background:#fff88f"><font color="#c00000">其字长不定</font></span>，取决于具体计算机。
		<font color="#9bbb59">存储字长</font>：存储单元中二进制的位数。
		<font color="#9bbb59">存储元</font>：用于存储二进制的电子元件，每个存储元可存储1bit。

运算器的组成：
	运算器主要由以下几个部件组成(三个寄存器加一个算术单元)：
		ACC：累加器，用于存放操作数或运算结果。
		MQ：乘商寄存器，用于存放操作数(乘数、被除数)或运算结果，<font color="#c00000">仅在乘法或除法中使用</font>。
		X：通用操作数寄存器(通常有多个)，用于<span style="background:#fff88f"><font color="#c00000">存放操作数</font></span>(加数、被乘数、除数)。
		<span style="background:#fff88f"><font color="#c00000">ALU</font></span>：算术逻辑单元，其由复杂的逻辑电路构成，用于实现算术操作。
	其结构如下：
		![[Pasted image 20240329175600.png]]

控制器的基本组成：
	控制器的基本组成主要由以下几个部件组成：
		<span style="background:#fff88f"><font color="#c00000">CU</font></span>：控制单元，用于分析指令和给出控制信号
		IR：指令寄存器，存放当前所执行的指令
		PC：程序计数器，用于存放下一条指令的地址，有自动加一的功能
	控制器完成一条指令的流程为：
	1. 从PC指向的地址取指令
	2. 使用IR分析指令
	3. 使用CU执行指令
	其中，前两个阶段可以合并称为取指令阶段，最后一个阶段为执行指令的阶段。

接下来可以简单模拟一下CPU执行如下C语言代码的流程：
```C
void func()
{
    int a = 1, b = 2;
    a = a + b;
}
```

其会被编译为如下汇编代码：
```asm
func:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], 1; 将1赋值给a，下述分析流程将从此开始
        mov     DWORD PTR [rbp-8], 2; 将2赋值给b
        mov     eax, DWORD PTR [rbp-8]; 将b存储到通用寄存器eax
        add     DWORD PTR [rbp-4], eax; 执行加法运算，并将结果缓存到第一个操作数
        nop
        pop     rbp
        ret
```

从 `mov     DWORD PTR [rbp-4], 1` 开始分析，此时二进制指令如下：

| 主存相对地址<br>(从标签 `func` 开始计算) | <center>指令</center>              | <center>注释</center>                     |
| :-------------------------: | -------------------------------- | --------------------------------------- |
|              0              | `push    rbp`                    |                                         |
|              1              | `mov     rbp, rsp`               | 将栈指针 `rsp` 存入当前函数栈基 `rbp`               |
|              2              | `mov     DWORD PTR [rbp-4], 1`   | 栈向下增长，将1存入堆栈基址下的第一个双字节地址                |
|              3              | `mov     DWORD PTR [rbp-8], 2`   | 将2存入第二个双字节地址(`DWORD` 的 `d` 意为 `double`) |
|              4              | `mov     eax, DWORD PTR [rbp-8]` | 将第二个双字节地址存入 `eax` 通用寄存器                 |
|              5              | `add     DWORD PTR [rbp-4], eax` | 执行 `ADD` 指令，将第一个双字节地址加 `eax` 并存于原位      |
|              6              | `nop`                            | 无操作，空闲一个机器周期                            |
|              7              | `pop     rbp`                    | 将 `rbp` 压入栈中                            |
|              8              | `ret`                            | 将函数return                               |

则从指令 `mov     DWORD PTR [rbp-4], 1` 开始，该计算机的工作流程为：
0. `PC` 指向内存地址 `2` ，并运行完内存地址为 `1` 中的指令。
1. 此时 `PC` 指向地址 `2` ，取 `PC` 指向的指令，且 `PC` 自动加一。该过程的具体流程为：
	1. 将 `PC` 中的值存入 `MAR` ，并且 `PC` 自增
	2. 主存储器根据 `MAR` 指向的地址读取内存
	3. 主存储器将 `MAR` 指向的指令 `mov     DWORD PTR [rbp-4], 1` 存入 `MDR`
	4. `MAR` 中的数据通过数据总线存入指令寄存器 `IR` 中
	5. `IR` 中的操作码部分会被存入控制单元 `CU` 中，并分析操作码
	6. 控制单元 `CU` 会将 `[rbp-4]` 和 `1` 分别存入 `MAR` 和 `MDR` 中，以修改 `[rbp-4]` 中的数据。
2. 此时 `PC` 指向地址 `3` ，取 `PC` 指向的指令，且 `PC` 自动加一。
3. 此时 `PC` 指向地址 `4` ，取 `PC` 指向的指令，且 `PC` 自动加一。该过程的具体流程为：
	1. 将 `PC` 中的值存入 `MAR` ，并且 `PC` 自增
	2. 主存储器根据 `MAR` 指向的地址读取内存
	3. 主存储器将 `MAR` 指向的指令 `mov     eax, DWORD PTR [rbp-8]` 存入 `MDR` 
	4. `MAR` 中的数据通过数据总线存入指令寄存器 `IR` 中
	5. `IR` 中的操作码部分会被存入控制单元 `CU` 中，并分析操作码
	6. 控制单元 `CU` 会将 `[rbp-8]` 中的数据存入通用寄存器 `eax` 中。
4. 此时 `PC` 指向地址 `5` ，取 `PC` 指向的指令，且 `PC` 自动加一。该过程的具体流程为：
	1. 将 `PC` 中的值存入 `MAR` ，并且 `PC` 自增
	2. 主存储器根据 `MAR` 指向的地址读取内存
	3. 主存储器将 `MAR` 指向的指令 `add     DWORD PTR [rbp-4], eax` 存入 `MDR` 
	4. `MAR` 中的数据通过数据总线存入指令寄存器 `IR` 中
	5. `IR` 中的操作码部分会被存入控制单元 `CU` 中，并分析操作码
	6. 控制单元 `CU` 会将 `[rbp-4]` 存入 `MAR` 中
	7. 主存储器根据 `MAR` 指向的地址读取内存
	8. 主存储器将 `MAR` 指向的数据 `1` 存入 `MDR`
	9. 控制单元 `CU` 将 `MDR` 中的数据存入 `ACC` 中
	10. 执行加法运算，并将结果存入 `ACC` 中
	11. 控制单元 `CU` 将 `[rbp-4]` 和 `ACC` 中的数据分别存入MAR和MDR中，以修改 `[rbp-4]` 中的数据。
5. 余下略。

### 1.1.3 计算机系统的层次结构

在上述例子中，每行汇编指令就是一个<font color="#9bbb59">传统机器指令</font>，而每个汇编指令背后所需要执行的操作就是<font color="#9bbb59">微程序机器指令</font>。











