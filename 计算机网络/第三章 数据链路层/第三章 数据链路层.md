#计算机网络 #应试笔记与八股 

## 目录
```toc
```
## 3.1 数据链路层的功能

如七层结构图所示：
![[Pasted image 20240205010846.png]]
在数据从主机A传送向主机B的过程中，数据包需要层层封包到物理层，再层层解包回应用层以传递到主机B。

当单独研究数据链路层时，可以只研究路径上各数据链路层水平方向上的数据传递，如下图所示：
![[Pasted image 20240304131032.png]]

则数据链路层的功能主要有：
- 为网络层提供服务，将可能出现差错的物理层改造为逻辑上无差错的数据链路，使数据链路层对网络层表现为一条无差错的链路。
- 链路管理
- 封装成帧和透明传输
- 流量控制
- 差错控制

基本概念：
- 结点：例如主机、路由器
- <font color="#9bbb59">链路</font>：指网络中两个节点之间的物理通道，链路的介质主要有双绞线、光纤、电磁波等。
- <font color="#9bbb59">数据链路</font>：指网络中两个节点之间的逻辑通道，把控制数据传输协议的硬件和软件加到链路上就构成数据链路。
- <font color="#9bbb59">帧</font>：链路层的协议数据单元，封装网络层数据报。

### 3.1.1 为网络层提供服务

数据链路层通常可以为网络层提供如下类型的服务：
1. 无确认的无连接服务，源机器只负责发送，目的机器也不需要发回确认。
2. 有确认的无连接服务，源机器负责发送，目的机器收到帧后必须发回确认。源机器在规定时间内未收到确认信号时就会重复传输丢失的帧。
3. 有确认的面向连接服务，对于此类型服务通常需要进行三个阶段：建立数据链路、传输帧、释放数据链路。
注：
1. 有连接就一定有确认，<font color="#c00000">不存在无确认的面向连接服务</font>。

### 3.1.2 链路管理

主要负责面向连接服务中连接的建立、维持和释放。

### 3.1.3 封装成帧和透明传输

封装成帧：
	如[[第一章 计算机网络体系结构#1 2 2 ISO OSI参考模型和TCP IP模型]]所述，数据链路层会对网络层传来的IP数据报添加头部 `H2` 和尾部 `T2` 。
	![[Pasted image 20240304133752.png]]
	其中帧的数据部分就是<font color="#c00000">最大传送单元(MTU)</font>，而<font color="#c00000">首部和尾部的重要作用就是帧定界</font>。

<font color="#9bbb59">透明传输</font>：
	不管链路层所传的数据是什么样的组合，都不应当影响其在链路上传输，故称为透明传输。

而常用的组帧方法有：
1. 字符计数法：用帧首部的一个字节(Byte)来标明帧内的字符数。
	![[Pasted image 20240304134441.png]]
	问题：<font color="#c00000">容易出错</font>。
2. 字符填充法：给一个固定的帧头帧尾，并提供冲突解决方法。
	![[Pasted image 20240304134613.png]]
	冲突解决方法：
	1. 当传输的是文本文件的时候一般不存在问题(数据部分和帧头、帧尾不可能出现重复)
	2. 当传输的是二进制文件的时候，需要在于帧头、帧尾以及转义字符(`ESC`)相同的二进制数据部分前加转义字符，如下图所示：
		![[Pasted image 20240304135100.png]]
	问题：
	1. 较为复杂且不稳定，<font color="#c00000">因此常用下方两种方法</font>。
3. 零比特填充法：给一个固定的帧头帧尾(`01111110`)，并通过打断连续的 `1` 来避免数据和帧头帧尾重复：
	冲突解决方法：
		当遇到连续的5个 `1` 时就会向其中添加一个 `0` ，以避免和帧头帧尾重复。
4. 违规编码法：例如当使用曼彻斯特编码等编码方式时，使用违规的编码来当做定界符。如局域网的 `IEEE 802.11` 标准就采用了此方法。
	具体实现(以曼彻斯特编码为例)：
		曼彻斯特编码规定 `前高后第表示1，前低后高表示0(或反之)` ，则可以使用 `前高后高` 、 `前低后低` 当做定界符。

### 3.1.4 流量控制和可靠传输

<font color="#c00000">流量控制同时负责流量控制和可靠传输</font>。
链路层的流量控制主要依靠于接收方的应答机制，接收方来不及接收时无应答。
流量控制的方法主要有：
1. <font color="#9bbb59">停止-等待协议</font>(可以认为是窗口大小为1的滑动窗口协议)：每发送完一个帧就停止发送，直到接收方确认后再继续发送。
	![[Pasted image 20240304161222.png]]
	缺点：传输效率低
2. <font color="#9bbb59">滑动窗口协议</font>：每个窗口有固定大小，窗口内的帧可以不等待接收方的确认信息连续发送，当发送方每收到一个确认回应，窗口就会往前移动一格。<font color="#c00000">链路层的窗口大小在整个发送过程中固定不变</font>。
	1. 后退N帧协议(GBN)
	2. 选择重传协议(SR)

基本概念：
- <font color="#9bbb59">信道利用率</font>：发送方在整个发送周期内，有效发送数据的时间占整个发送周期的比率：$$\frac{\frac{T时间内发送的数据长度L}{发送方的数据传输率}}{发送周期T}$$
- <font color="#9bbb59">信道吞吐率</font>：$$信道吞吐率=信道利用率\times 发送方的发送速率$$

#### 3.1.4.1 停止-等待协议

在讨论停止等待协议时，通常把网络认为是半双工模型，即发送和接收只能间隔执行。
差错主要可以分为：
1. 帧丢失或帧出错
	对于帧丢失或帧出错，则主要依靠发送方的超时计时器完成，当超过预定的时间没有收到 `ACK` 回应时则自动启动重传机制。通常超市计时器的最长时长会大于平均RTT。
	![[Pasted image 20240305150206.png]]
2. `ACK` 丢失
	对于 `ACK` 丢失，发送方会再次发送对应帧，但是接收方在收到重复帧后会丢弃重复帧并重传对应的 `ACK` 。
	![[Pasted image 20240305150602.png]]
3. `ACK` 迟到
	类似于情况2的操作。当发送方收到重复的 `ACK` 后会丢弃该 `ACK` 。
	![[Pasted image 20240305150816.png]]


具体机制：
1. 发送完一个帧后，发送方必须保存一个副本，只有当收到 `ACK` 回应后才会将其删除。
2. 数据帧和确认帧必须编号，以解决帧重复问题。

优点：
1. 简单

缺点：
1. 信道利用率低

#### 3.1.4.2 后退N帧协议(GBN)

具体机制：
1. 发送方的发送窗口大小为 `N` ，同时发送 `N` 帧；<span style="background:#fff88f"><font color="#c00000">接收方的接收窗口为</font></span> `1` 。
2. <font color="#c00000">接收方在接收完前</font> `k` <font color="#c00000">帧时会返回第</font> `k` <font color="#c00000">帧的</font> `ACK` ，将自己的接收窗口移动到 `K+1` 帧的同时并通知发送方将窗口向后移动到 `K+1` 帧。(<font color="#c00000">注意</font> `ACK` <font color="#c00000">是累计确认</font>)
3. <span style="background:#fff88f"><font color="#c00000">接收方只接收当前接收窗口的帧</font></span><font color="#c00000">，即使收到窗口后续位置的帧也会被接收方丢弃</font>。

其中，发送方需要响应的事件有：
1. 响应上层的调用，如果缓存区域已满则通知上层等待。
2. 响应接收方的 `ACK` 。
3. `ACK` 响应超时，当 `ACK` 响应超时时，<font color="#c00000">发送方会重新发送所有已发送但未被确认的帧</font>。

接收方需要处理的事情有：
1. 如果正确<span style="background:#fff88f"><font color="#c00000">按序</font></span>收到 `n` 号帧，那么将返回 `n` 号帧对应的 `ACK` 给发送方。
2. 如果收到的是非窗口帧，则返回窗口前一帧的 `ACK` (并用此 `ACK` 将窗口帧号同步给发送方)。(窗口帧号会存入 `expectedseqnum`)

注意：
1. <span style="background:#fff88f"><font color="#c00000">接收方只按序接收</font></span>
2. <span style="background:#fff88f"><font color="#c00000">接收方只会累计确认</font></span>
3. <font color="#c00000">如果接收方收到非顺序帧，则会返回前一帧的</font> `ACK` 。
4. 发送窗口大小一般等于$$2^{n-1}$$

大致流程：
	![[Pasted image 20240305154657.png]]

优点：
1. 使用连续发送从而提高了信道利用率。
缺点：
1. 会丢弃正确但是顺序不对的帧，使传输效率降低。

#### 3.1.4.3 选择重传协议(SR)

具体机制：
1. 发送方的发送窗口大小为 `N` ，同时发送 `N` 帧；<span style="background:#fff88f"><font color="#c00000">接收方的接收窗口也为</font></span> `N` (发送窗口一般等于接收窗口)。
2. 设置单个确认机制，只选择错误帧重传。
3. 发送端只有前面的帧都被确认后才会移动窗口。

发送方必须响应的事件：
1. 响应上层的调用，如果缓存区域已满则通知上层等待。
2. 响应接收方的 `ACK` ，并将对应窗口标记为已接收，并检查是否需要移动窗口。
3. `ACK` 响应超时，<font color="#c00000">每个帧都有自己的定时器</font>，<span style="background:#fff88f"><font color="#c00000">一个超时事件发生后只重传一个帧</font></span>。

接收方需要处理的事情有：
1. 对于接收窗口内的帧来者不拒并响应 `ACK` ，如果收到了小于窗口下界的会相应对应 `ACK` ，其他情况会忽略该帧。
2. 当一个连续的帧序列接收完毕后，滑动窗口并将已接收的帧返回给上层。

注意：
1. <span style="background:#fff88f"><font color="#c00000">对每一个帧都设置单个确认机制，收到一个确认一个</font></span>。
2. <font color="#c00000">只重传错误帧</font>。
3. <font color="#c00000">接收方有缓存帧</font>。
4. 发送窗口的大小和接收窗口的大小应当相等，且等于$$2^{n-1}$$

### 3.1.5 差错控制

通常来说，传输过程中的差错都是由于噪声所引起，而噪声可以简单分类为如下两种：
1. <font color="#9bbb59">全局性噪声</font>：由于线路电气特性所带来的随机噪声(热噪声)，一般通过提高信噪比来减少干扰。
2. <font color="#9bbb59">局部性噪声</font>：由于外界特定的短暂原因所造成的冲击噪声，<font color="#c00000">是差错产生的主要原因</font>。主要通过编码技术来解决。

差错主要分为：
1. <font color="#9bbb59">位错</font>：比特位出错。
2. <font color="#9bbb59">帧错</font>：帧丢失、帧重复、帧失序。可以使用对帧编号、确认重传机制等处理(<font color="#c00000">前提是使用有确认的服务</font>)。

位错的解决方法有：
1. 检错编码：
	1. 奇偶校验码
	2. 循环冗余码(CRC)，<font color="#c00000">普遍使用此方式</font>。
2. 纠错编码，例如海明码。

#### 3.1.5.1 检错编码

<font color="#9bbb59">奇偶校验码</font>：
	前 `n-1` 位为信息源，最后一位表示序列中 `1` 的数量的奇偶。

<font color="#9bbb59">循环冗余码(CRC)</font>：
	计算循环冗余码需要提供 `原数据` 和 `生成多项式` 参数，对原数据进行补位，随后对 `生成多项式` 进行 `模二` 取余，即可得CRC校验码。

CRC校验码的计算步骤：
例如给定：
1. 原数据： `101001`
2. 生成多项式： `1101` 或：$$x^3+x^2+0x+1x^0$$(本质等价，见注1)
则有如下运算：
1. 生成多项式的有效长度为<font color="#c00000">4</font>，故对原数据后补<font color="#c00000">3</font>个 `0` ，即： `101001000` 。(因为生成多项式中 `x` 最高阶为<font color="#c00000">3</font>)。
2. 对 `101001000000` 进行 `1101` 的 `模二` 除法(<font color="#c00000">即异或除法</font>)：
	1. 先对从左往右第4位的商处填 `1` ,并对前4位 `1010` 和 `1101` 进行异或算法，得 `111` ：
		![[Pasted image 20240304150024.png]]
		
	2. 将第5位 `0` 补位得 `1110` ，并继续对 `1101` 进行 `模二` 除法，有：
		![[Pasted image 20240304150312.png]]
	3. 循环往复处理到最后一位有：
		![[Pasted image 20240304150334.png]]
	4. 则可得最终余数为 `1` ，即CRC的FCS，最终结果为 `101001001` <font color="#c00000">并发送给接收方</font>。
	5. 接收方验证 `101001001` 对 `1101` 进行 `模二` 运算，如果为0，则验证成功。

<span style="background:#fff88f"><font color="#c00000">CRC校验的发送方和接收方均由硬件实现该过程，不用担心校验速度</font></span>。使用CRC校验的通过校验的帧有<span style="background:#fff88f"><font color="#c00000">接近为1的概率</font></span>没有出现差错。

注：
1. 生成多项式有两种表达式，即：
	`1101` 和：$$x^3+x^2+0x+1x^0$$
	等价。

#### 3.1.5.2 纠错编码

检错编码只能检查错误的发生而无法纠正错误，故有了同时可以检错和纠错的纠错编码，例如海明码。

基本概念：
- <font color="#9bbb59">海明距离</font>(汉明距离)：对于两串等长数据，其相同位置不同的bit位的数量即为海明(汉明)距离，例如：
	- `11001`
	- `00111`
	的海明距离为 `4` 。
- 编码系统的海明距离(<font color="#9bbb59">码距</font>)：对于一个有效编码集，其任意两个元素见最短的汉明距离即为该编码的码距。例如编码集：
	- `000`
	- `001`
	- `010`
	- `...`
	的码距就为1，而编码集：
	- `0000`
	- `1001`
	- `1010`
	- `...`
	的码距就为2。

做以下讨论：
1. 码距为1的编码系统能否发现错误?(不能)
2. 码距为2的编码系统能否发现错误?(可以，如果bit只变了一位，则就可以发现错误)
3. 码距为n的编码系统最多可以检测出有多少bit错误的编码?(n-1位)
4. 码距为3的编码系统最多可以<font color="#c00000">纠正</font>多少位的bit错误?(2位)
5. 如果要<font color="#c00000">检测</font>最多为n位bit的错误，则码距至少为多少?(n+1)
6. 如果要<font color="#c00000">纠正</font>最多为n位bit的错误，则码距至少为多少?(2n+1)

基于以上讨论，对于信息数据 `m` 位，校验码 `r` 位，有效位数为 `m+r` 位的编码，只用校验码可以表示出多少种错误? `m+r` 有效位的编码能发生多少种错误?
- 校验码可以表示的错误种类数为：$$2^r$$
- `m+r` 有效位的编码能发生的错误种类数为：$$m+r$$
故有<font color="#c00000">海明不等式</font>：
$$2^r\geq m+r+1$$
<span style="background:#fff88f"><font color="#c00000">该公式可以确定海明码的位数</font></span>，有了理论基础，则海明码具体编码过程如下：
1. <font color="#c00000">利用海明不等式确定海明码的位数</font>，例如待编码的数据位为4，则有：$$2^r\geq 4+r+1$$
	则有满足要求的解 `r>=3` ，<span style="background:#fff88f"><font color="#c00000">可以满足带编码位数为4的海明码的位数为 <code>m+r=7</code> 位</font></span>。
2. <span style="background:#fff88f"><font color="#c00000">将7位编码中2的n次幂的位置留下当做校验码位</font></span>，余下当做数据位

| 位号    |  7  |  6  |  5  |     4      |  3  |     2      |     1      |
| ----- | :-: | :-: | :-: | :--------: | :-: | :--------: | :--------: |
| **值** |     |     |     | 校验位$$2^2$$ |     | 校验位$$2^1$$ | 校验位$$2^0$$ |
3. 填充数据位(例如给定数据 `1101` )：

| 位号    |               7                |               6                |               5                |     4      |               3                |     2      |     1      |
| ----- | :----------------------------: | :----------------------------: | :----------------------------: | :--------: | :----------------------------: | :--------: | :--------: |
| **值** | <font color="#c00000">1</font> | <font color="#c00000">1</font> | <font color="#c00000">0</font> | 校验位$$2^2$$ | <font color="#c00000">1</font> | 校验位$$2^1$$ | 校验位$$2^0$$ |
4. 规定在2的n次幂的位置的校验位负责管理非n位的校验，例如：

| 位号                                       |               7                |               6                |               5                |     4      |               3                |     2      |     1      |
| ---------------------------------------- | :----------------------------: | :----------------------------: | :----------------------------: | :--------: | :----------------------------: | :--------: | :--------: |
| **二进制位号**                                |              111               |              110               |              101               |    100     |              011               |    010     |    001     |
| **值**                                    | <font color="#c00000">1</font> | <font color="#c00000">1</font> | <font color="#c00000">0</font> | 校验位$$2^2$$ | <font color="#c00000">1</font> | 校验位$$2^1$$ | 校验位$$2^0$$ |
| **<font color="#c00000">校验位管理区域</font>** |                                |                                |                                |   `1**`    |                                |   `*1*`    |   `**1`    |
则有：
- 位号为4的校验位负责管理二进制位号为 `1**` 的数据位的校验，即管理7、6、5、4位
- 位号为2的校验位负责管理二进制位号为 `*1*` 的数据位的校验，即管理7、6、3、2位
- 位号为1的校验位负责管理二进制位号为 `**1` 的数据位的校验，即管理7、5、3、1位
5. 填写每个校验位，使得每个校验位管理区域之和为偶数(或奇数)，即：

| 位号        |               7                |               6                |               5                |  4  |               3                |  2  |  1  |
| --------- | :----------------------------: | :----------------------------: | :----------------------------: | :-: | :----------------------------: | :-: | :-: |
| **二进制位号** |              111               |              110               |              101               | 100 |              011               | 010 | 001 |
| **值**     | <font color="#c00000">1</font> | <font color="#c00000">1</font> | <font color="#c00000">0</font> |  0  | <font color="#c00000">1</font> |  1  |  0  |
6. 即可得对应数据的海明码 `1100110` 。

校验过程：
1. 假如接收方收到的数据为： `1110110`
2. 验算4号校验码：$$x_4=1+1+1+0=1$$
3. 验算2号校验码：$$x_2=1+1+1+1=0$$
4. 验算1号校验码：$$x_1=1+1+1+0=1$$
5. 将各校验码按照如下拼接：$$(x_4)(x_2)(x_1)=101=5$$
6. 故错误位置为5，原海明码为 `1100110` 。

## 3.2 介质访问控制

链路层数据传输链路通常有两种：
1. <font color="#9bbb59">点对点链路</font>：两个节点通过一个链路介质相连，例如广域网的PPP协议。
2. <font color="#9bbb59">广播式链路</font>：所有主机共享通信介质，例如无线局域网等。该链路的典型拓扑结构有总线型和星型。

而介质访问控制主要就是解决广播式链路的通信可能发生互相干扰的情况。其主要有两种：
1. <font color="#9bbb59">静态划分信道</font>，一般使用信道划分介质访问控制，主要有：
	1. 频分多路复用(FDM)
	2. 时分多路复用(TDM)
	3. 波分多路复用(WDM)
	4. 码分多路复用(CDM)
2. <font color="#9bbb59">动态划分信道</font>，主要有：
	1. <font color="#9bbb59">轮询介质访问控制</font>，主要是令牌传递协议
	2. <font color="#9bbb59">随机介质访问控制</font>，主要有：
		1. ALOHA协议
		2. CSMA协议
		3. <font color="#c00000">CSMA/CD协议</font>
		4. <font color="#c00000">CSMA/CA协议</font>

### 3.2.1 信道划分控制协议

主要依靠对<font color="#c00000">时域</font>、<font color="#c00000">频域</font>资源的合理划分(即多路复用技术)来控制对应的网络设备。

频分多路复用(FDM)：
- 将频带分配给所有用户进行使用
- 优点：
	- 技术成熟、实现简单
	- 系统效率较高
- 频分多路复用类似于 `并行` ，时分多路复用类似于 `并发` 。

时分多路复用(TDM)：
- 将一个周期(TDM帧)划分为多个时间片分配给所有用户进行使用
- 缺点：
	- 每个设备只能使用每个周期中固定的时间片的时间(即使其他设备空闲)，会造成信道利用率低，改进方法为统计时分多路复用(STDM)。
- 频分多路复用类似于 `并行` ，时分多路复用类似于 `并发` 。
- 注：
	1. TDM帧是物理层上的时间片，并非链路层的帧。
	![[Pasted image 20240305171232.png]]


统计时分多路复用(STDM)：
	设计如下的逻辑结构：
	![[Pasted image 20240305171830.png]]
	将若干设备传送来的数据缓存入集中器的缓存中，集中器再将数据划分打包为STDM帧进行发送。
- 注：
	1. STDM帧是物理层上的时间片，并非链路层的帧。
	2. STDM帧对设备来说并非固定分配时间片，而是按需分配，信道利用率高。
	3. 相较于TDM的固定分配带宽(无法完全占用信道)，STDM可以使设备达到最大通信速率。

波分多路复用(WDM)：
	波分多路复用就是光的频分多路复用
	![[Pasted image 20240305172349.png]]

码分多路复用(CDM)：
- 通过数学上的运算将若干台设备的数据使用自身序列号按一定规则编码，接收设备可以按照对应规则解析出特定发送设备所发送的值。
- 例如CDMA码分多址规则：
	- 假设发送端A、B分别被指定了一个8位的芯片序列 `00011011` 、 `11010001` ，且保证将序列中的 `0` 置换为 `-1` 后，<font color="#c00000">所有序列两两正交</font>。即A的 `-1 -1 -1 1 1 -1 1 1` 和B的 `1 1 -1 1 -1 -1 -1 1` 正交。(则8位的序列一共有8个两两正交的序列)
	- 随后当设备发送bit `0` 时，发送序列中的 `0` 置换为 `-1` 后的负码；发送bit `1` 时，发送发送序列中的 `0` 置换为 `-1` 后的码。例如：
		- 设备A发送bit `0` ，则发送 `1 1 1 -1 -1 1 -1 -1` 。
		- 设备A发送bit `1` ，则发送 `-1 -1 -1 1 1 -1 1 1` 。

### 3.2.2 动态分配信道

动态分配信道的特点是信道并非在用户通信时固定分配给用户的。

#### 3.2.2.1 [TODO]轮询访问介质控制



#### 3.2.2.2 随机访问介质控制

随机访问介质控制的所有用户可以随时发送信息，发送信息时也可以占用全部带宽。其实现方式主要有：
1. ALOHA协议
2. CSMA协议
3. <font color="#c00000">CSMA/CD协议</font>
4. <font color="#c00000">CSMA/CA协议</font>

##### 3.2.2.2.1 ALOHA协议

ALOHA协议可以分为纯ALOHA协议和时隙ALOHA协议。

纯ALOHA协议：
	不监听信道，不按时间槽(将时间分为一个个等距时间片就叫时间槽)发送，随机重发；当发生冲突时，接收方不发送确认帧，当发送方等待确认帧超时后就可判定发生冲突，随后等待<span style="background:#fff88f"><font color="#c00000">随机时间</font></span>后重传。
	![[Pasted image 20240310192204.png]]

时隙ALOHA协议：
	将时间划分为若干时间片，所有用户在开始时同步时间片，随后按照时间槽发送数据
	![[Pasted image 20240310192535.png]]

特点：
1. 纯ALOHA协议比时隙ALOHA协议吞吐量低，效率也更低。
2. 纯ALOHA想发就发，不用遵循时间槽，而时隙ALOHA需要。

##### 3.2.2.2.2 CSMA协议

CSMA协议全称为 `Carrier Sense Multiple Access` ，即载波监听多路访问协议。
- `Carrier Sense` 载波监听，在每一个站点发送数据前都要检查一下总线上是否有其他计算机在发送数据。
- `Multiple Access` 多点接入，多个计算机连接到一个总线上。

协议思想：
	先监听信道是否空闲(通过检测总线上的电压摆动值)，当信道空闲时发送完整帧，信道忙时推迟发送。根据信息发送的规则可以分为 `1-坚持CSMA` 、 `非坚持CSMA` 、 `p-坚持CSMA` 。

**1-坚持CSMA**：
1. 当信道忙时则一直监听，直到空闲时马上传输。
2. 当冲突发生时，则等待一个随机长的时间后再次监听并尝试发送。

优点：
1. 只要信道空闲就可以立即发送，避免了传输媒体利用率的浪费。

缺点：
1. 当有两个或两个以上的站点在等待信道空闲时，则无可避免的发生冲突。

**非坚持CSMA**：
1. 当信道忙时则等待随机长的时间后再次进行监听，若空闲则立刻传输。

优点：
1. 采用随机的等待时间减少了冲突发生的可能性。

缺点：
1. 可能造成所有设备都在等待的情况，造成媒体利用率的降低。

**p坚持CSMA**：
1. 当信道空闲时以概率 `p` 排定发送数据，概率 `1-p` 判定等到下一个时间槽再发送。
2. 当信道忙时则等到信道闲时在进行上述判定。

优点：
1. 既能像 `1-坚持` 那样减少媒体空闲率，也能像 `p-坚持` 那样减少冲突。

三种方法对比如下：
	![[Pasted image 20240310195156.png]]

<span style="background:#fff88f"><font color="#c00000">但是上述三种CSMA算法均无法做到在发送数据时就知晓冲突发生了的</font></span>，都会将数据坚持发送完毕并等待超时才会知晓，造成了浪费。

##### 3.2.2.2.3 [TODO]CSMA/CD协议

##### 3.2.2.2.4 [TODO]CSMA/CA协议


## 3.3 局域网

### 3.3.1 局域网的基本概念和体系结构

基本概念：
- <font color="#9bbb59">局域网</font>(<font color="#9bbb59">LAN</font>，<font color="#9bbb59">Local Area Network</font>)：某一区域内由多台计算机互联组成的计算机组，<font color="#c00000">使用广播通信</font>。

特点：
1. 覆盖区域小
2. 一般会铺设专用的通信介质(无线局域网除外)
3. 数据传输速率高，通信延迟低，误码率低，可靠性高

局域网介质访问控制方法：
1. CSMA/CD，常用于总线型局域网，也用于树形网络
2. 令牌总线，常用于总线型局域网，也用于树形网络
3. 令牌环，常用于环形局域网，如令牌环网

局域网的分类主要有：
1. 以太网，逻辑拓扑为总线型，物理拓扑为星型或拓展星型，<font color="#c00000">使用IEEE 802.3标准</font>。
2. 令牌环网，逻辑拓扑为环形，物理拓扑为星型，<font color="#c00000">使用IEEE 802.5标准</font>。已不常使用。
3. FDDI网(Fiber Distributed Data Interface)，物理上使用双环拓扑，逻辑上是环形拓扑，<font color="#c00000">使用IEEE 802.8标准</font>。
4. ATM网(Asynchronous Transfer Mode)，使用的是固定长度的交换单元
5. 无线局域网(WLAN)，<font color="#c00000">使用IEEE 802.11标准</font>。

IEEE 802系列技术标准的委员会是1980年2月成立，故叫IEEE 802委员会，其重要标准有：
- `IEEE 802.3` ：以太网访问控制协议(`CSMA/CD`)及其物理层规范
- `IEEE 802.5` ：令牌环网的介质控制协议及物理层技术规范
- `IEEE 802.8` ：光纤技术咨询组
- `IEEE 802.11` ：无线局域网的介质控制协议及其物理层规范

### 3.3.2 以太网与IEEE 802.3协议

<span style="background:#fff88f"><font color="#c00000">局域网和以太网的概念</font></span>：
1. 局域网(LAN)是指使用了 `IEEE 802.3` 标准的网络
2. 以太网(Ethernet)是指符合 `DIX Ethernet V2` <font color="#c00000">标准的</font><span style="background:#fff88f"><font color="#c00000">局域网</font></span>
3. 以太网是局域网的子集，但是 `IEEE 802.3` 标准和 `DIX Ethernet V2` 标准的差异不大，<font color="#c00000">因此通常将IEEE 802.3局域网简称为以太网</font>，以太网主要简化了通信流程并使用了CSMA/CD方式对总线进行访问控制。

`IEEE 802.3` 协议描述的局域网参考模型只对应了OSI七层协议的数据链路层和物理层，其将数据链路层划分为逻辑链路层LLC和介质访问控制层MAC，如下图所示：
	![[Pasted image 20240310202718.png]]
LLC和MAC主要负责的内容如下：
- LLC子层：
	1. 负责识别网络协议，并对齐进行封装传递给MAC子层。
	2. 为网络层提供服务，如无确认无连接服务、面向连接服务、带确认无连接服务和高速传送服务。
- MAC子层：
	1. 负责数据帧的封装、卸装，帧的发送与接收。
	2. 负责链路管理，帧的差错控制。
	3. <font color="#c00000">屏蔽了不同物理链路种类的差异性</font>。

### 3.3.3 无线局域网与IEEE 802.11

IEEE 802.11系列标准是无线局域网的，当前其拥有 `IEEE 802.11` 原始标准、 `IEEE 802.11a` 扩充标准到 `IEEE 802.11h` 扩充标准。

无线局域网与Wi-Fi的关系：
1. Wi-Fi是无线局域网的子集，只有通过 Wi-Fi Alliance 认证的产品才可以使用 `Wi-Fi` 商标。
2. 但是 `Wi-Fi` 和 `IEEE 802.11` 所规定的其他无线局域网属于相同的技术范畴。

无线局域网可以分为：
1. 有固定基础设施的无线局域网，其基本结构如下：
	![[Pasted image 20240310210538.png]]
	其基本概念：
	- <font color="#9bbb59">基本服务集</font>：每个无线接入点及接入点所覆盖的主机所构成的集合就叫做基本服务集。
	- <font color="#9bbb59">服务集标识符</font>(<font color="#9bbb59">SSID</font>，Service Set Identifier)：用于识别每个基本服务集的标识符。
2. 无固定基础设施的无线局域网，又称为<font color="#9bbb59">自组网络</font>，其基本结构如下：
	![[Pasted image 20240310210747.png]]
	<font color="#c00000">把所有主机安排在同一网段即可完成组网</font>，各节点地位平等，中间结点均为转发节点，均具有路由器的功能。

#### 3.3.3.1 IEEE 802.11的MAC帧帧头格式

IEEE 802.11所规定的MAC帧帧头结构如下：
	![[Pasted image 20240310205008.png]]
假设无线通信的通信链路如下图所示，设备A向设备C通过AP1->R1->AP2进行通信：
	![[Pasted image 20240310205515.png]]
则由无线接入点AP1向AP2传输的过程中，其IEEE 802.11 WDS帧的MAC帧帧头各部分及其含义为：

| MAC部分 | <center>说明</center>   |
| ----- | --------------------- |
| 地址1   | 接收端地址，即无线接入点AP2的MAC地址 |
| 地址2   | 发送端地址，即无线接入点AP1的MAC地址 |
| 地址3   | 目的地址，即设备C的MAC地址       |
| 地址4   | 源地址，即设备A的MAC地址        |
其他类型的IEEE 802.11帧如下图所示：
	![[Pasted image 20240310210009.png]]

### 3.3.4 VLAN的基本原理与概念

<font color="#9bbb59">VLAN</font>(Virtual LAN)是一种将大的局域网划分为若干小的虚拟局域网的技术。其主要用于解决大局域网上的下列问题：
1. 当局域网中一个主机发送广播帧后，则该广播域中所有主机均会收到一次广播帧，则会引起宏泛现象。(例如ARP、RIP、DHCP协议等均会用到广播帧)
2. 不方便用户管理，例如在不使用VLAN做计算机分组等操作时可能要重新布设物理线路修改物理拓扑。
3. 如果用路由器做广播域隔离，则成本较高。
![[Pasted image 20240311145624.png]]
而VLAN<font color="#c00000">可以将局域网内的设备划分为与物理位置无关的逻辑组</font>的技术，<span style="background:#fff88f"><font color="#c00000">通常在交换机中实现</font></span>，每一个VLAN都是单独的子网(广播组)，如下图所示：
![[Pasted image 20240311145646.png]]
其有以下特点：
1. <font color="#c00000">不同VLAN间的网络层IP所属网段</font><span style="background:#fff88f"><font color="#c00000">通常</font></span><font color="#c00000">也不同</font>(但<font color="#c00000">不一定绝对不同</font>，可以把同一网段的不同IP分配给多个VLAN，只是这样做相对麻烦，在手动分配IP模式下也可能引起IP冲突)。
2. VLAN表的设备标识符可以使用交换机的 `物理端口号` 、 `设备MAC地址` 、 `IP地址` 等，分别称作 `基于端口的VLAN技术` 、  `基于MAC地址的VLAN技术` 、 `基于IP的VLAN技术` 。
3. 不同VLAN之间的通信需要经过第三层设备(路由器、三层交换机等)的网关后才能通信。
4. 上图中的<font color="#c00000">不同交换机</font>下<font color="#c00000">同一VLAN</font>的<font color="#c00000">不同设备</font>之间的通信需要通过交换机之间的 `Trunk Link` 接口来实现，可以在交换机的配置页面中指定 `Trunk Link` 端口，其<span style="background:#fff88f"><font color="#c00000">设备间的以太网MAC帧</font></span><font color="#c00000">会被改造为</font>下方[[第三章 数据链路层#^gen5pe]]的<span style="background:#fff88f"><font color="#c00000">IEEE 802.1Q帧</font></span>。
5. `Trunk Link` 和 `IEEE 802.1Q` 帧<font color="#c00000">无法解决不同VLAN间的通信</font>，<font color="#c00000">其VLAN标记是交换机负责添加和摘去的</font>，<font color="#c00000">对主机不可见</font>。

VLAN标记和IEEE 802.1Q帧 ^gen5pe
	在使用 `Trunk Link` 等技术进行跨交换机的VLAN内通信时，原设备发送的以太网MAC帧会被进行如下改造：
	![[Pasted image 20240311155422.png]]
	4Byte的VLAN标记中的：
		第1-2Byte用于表明该帧是IEEE 802.1Q帧
		第3-4Byte的<font color="#c00000">后12位</font>为VLAN标识符VID(<font color="#c00000">前4位没用</font>)
	<span style="background:#fff88f"><font color="#c00000">IEEE 802.1Q帧只用于交换机间的通信，主机之间仍然为MAC帧</font></span>。

`Trunk Link` 端口<font color="#c00000">类似于可以通过任意VLAN数据的端口</font>，当交换机在其所属设备的MAC地址表中找不到目标设备时，会向该VLAN中所有端口(包括 `Trunk Link` 端口)发送该数据帧。

## 3.4 广域网

### 3.4.1 广域网的基本概念

广域网是计算机网络的范围尺度的概念。互联网是广域网，但广域网不是互联网。
广域网的通信子网主要使用<font color="#c00000">分组交换技术</font>，数据传输延迟往往比局域网高。

### 3.4.2 PPP协议

PPP协议是当前使用最广泛的链路层协议，<font color="#c00000">只支持全双工链路</font>。
由于后续的网络层的IP等协议并不要求可靠传输，故<font color="#c00000">PPP协议也不要求可靠传输</font>。
PPP协议的特性如下：
1. 协议简单，无需纠错、无需序号、无需流量控制
2. 封装成帧
3. 透明传输
4. 支持多种传输层协议
5. 支持多种链路类型(如串行、并行，同步、异步，电缆、光纤)
6. 差错检测(添加FCS字段，使用CRC循环冗余算法，出错丢弃即可)
7. 检测连接状态，检测链路是否正常工作
8. 约定最大传输单元(<font color="#c00000">MTU</font>，默认小于1500Bytes)
9. 支持网络层地址协商(支持网络层实现IP协议及IP地址)
10. 数据压缩协商
PPP协议<span style="background:#fff88f"><font color="#c00000">无需满足</font></span>的特性：
1. 不需要实现纠错功能(只用检错丢弃)
2. 流量控制
3. 无需对帧编号
4. 不需要支持多点线路(即点对点协议)

PPP协议的三个组成部分：
1. 将IP数据报封装成帧
2. 实现链路控制协议(LCP)，完成身份验证
3. 网络控制协议(NCP)

PPP协议的状态图：
	![[Pasted image 20240311173905.png]]

PPP协议中，帧结构如下：
	![[Pasted image 20240311174123.png]]
其各部分含义如下表：

| <center>部分</center>  | <center>含义</center>                           |
| --- | --------------------------------------------- |
| F   | 帧定界符，固定为 `0xFF` ，若信息部分遇到 `0xFF` 则插入转义符 `0x7F` |
| A   | PPP协议预留的地址字段，迄今为止无意义，固定为 `0xFF`               |
| C   | PPP协议预留的控制字段，迄今为止无意义，固定为 `0x03`               |
| 协议  | 表示该数据报的类型，例如是IP数据报、LCP数据、网络层控制数据等             |
| FCS | CRC循环冗余算法的校验位。                                |

### 3.4.3 HDLC协议

HDLC(High Level Data Link Control，高级数据链路控制)协议，其特点为：
1. 主要适用于同步网
2. 面向Byte传输
3. 采用全双工协议
4. 使用CRC检验
5. 对信息帧编号，可靠性较高
其由ISO组织根据IBM公司的SDLC协议拓展开发而来，<font color="#c00000">不在TCP/IP协议簇中</font>，使用较少，考试不考，此处省略。


## 3.5 数据链路层设备

### 3.5.1 二层交换机

交换机按照所属层数可以分为：
- 二层交换机(数据链路层)。
- 三层交换机(网络层)，即带有路由功能的交换机。
- 四层交换机(传输层)
其中二层交换机的主要功能有：
1. 建立交换机的物理端口和其所连设备的MAC地址的映射，构造MAC地址表。
	![[Pasted image 20240311152740.png]]
2. 使用VLAN技术划分虚拟局域网，创建VLAN表。该VLAN表的关键字<font color="#c00000">不一定为交换机端口</font>，可以为<font color="#c00000">MAC地址</font>、<font color="#c00000">IP地址</font>(需要使用三层交换机)等。
	![[Pasted image 20240311152813.png]]
3. 转发设备间的数据帧，其中：
	1. 目标MAC地址在MAC地址表中的单播帧会向MAC地址表中对应的转发。
	2. 目标MAC地址不在MAC地址表中的单播帧会被广播到所有设备。
	3. 广播帧、组播帧的数据帧会被广播到所有设备。
