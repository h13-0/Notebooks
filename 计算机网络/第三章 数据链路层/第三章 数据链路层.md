#计算机网络 #应试笔记与八股 

## 目录
```toc
```
## 3.1 数据链路层的功能

如七层结构图所示：
![[Pasted image 20240205010846.png]]
在数据从主机A传送向主机B的过程中，数据包需要层层封包到物理层，再层层解包回应用层以传递到主机B。

当单独研究数据链路层时，可以只研究路径上各数据链路层水平方向上的数据传递，如下图所示：
![[Pasted image 20240304131032.png]]

则数据链路层的功能主要有：
- 为网络层提供服务，将可能出现差错的物理层改造为逻辑上无差错的数据链路，使数据链路层对网络层表现为一条无差错的链路。
- 链路管理
- 封装成帧和透明传输
- 流量控制
- 差错控制

基本概念：
- 结点：例如主机、路由器
- <font color="#9bbb59">链路</font>：指网络中两个节点之间的物理通道，链路的介质主要有双绞线、光纤、电磁波等。
- <font color="#9bbb59">数据链路</font>：指网络中两个节点之间的逻辑通道，把控制数据传输协议的硬件和软件加到链路上就构成数据链路。
- <font color="#9bbb59">帧</font>：链路层的协议数据单元，封装网络层数据报。

### 3.1.1 为网络层提供服务

数据链路层通常可以为网络层提供如下类型的服务：
1. 无确认的无连接服务，源机器只负责发送，目的机器也不需要发回确认。
2. 有确认的无连接服务，源机器负责发送，目的机器收到帧后必须发回确认。源机器在规定时间内未收到确认信号时就会重复传输丢失的帧。
3. 有确认的面向连接服务，对于此类型服务通常需要进行三个阶段：建立数据链路、传输帧、释放数据链路。
注：
1. 有连接就一定有确认，<font color="#c00000">不存在无确认的面向连接服务</font>。

### 3.1.2 链路管理

主要负责面向连接服务中连接的建立、维持和释放。

### 3.1.3 封装成帧和透明传输

封装成帧：
	如[[第一章 计算机网络体系结构#1 2 2 ISO OSI参考模型和TCP IP模型]]所述，数据链路层会对网络层传来的IP数据报添加头部 `H2` 和尾部 `T2` 。
	![[Pasted image 20240304133752.png]]
	其中帧的数据部分就是<font color="#c00000">最大传送单元(MTU)</font>，而<font color="#c00000">首部和尾部的重要作用就是帧定界</font>。

<font color="#9bbb59">透明传输</font>：
	不管链路层所传的数据是什么样的组合，都不应当影响其在链路上传输，故称为透明传输。

而常用的组帧方法有：
1. 字符计数法：用帧首部的一个字节(Byte)来标明帧内的字符数。
	![[Pasted image 20240304134441.png]]
	问题：<font color="#c00000">容易出错</font>。
2. 字符填充法：给一个固定的帧头帧尾，并提供冲突解决方法。
	![[Pasted image 20240304134613.png]]
	冲突解决方法：
	1. 当传输的是文本文件的时候一般不存在问题(数据部分和帧头、帧尾不可能出现重复)
	2. 当传输的是二进制文件的时候，需要在于帧头、帧尾以及转义字符(`ESC`)相同的二进制数据部分前加转义字符，如下图所示：
		![[Pasted image 20240304135100.png]]
	问题：
	1. 较为复杂且不稳定，<font color="#c00000">因此常用下方两种方法</font>。
3. 零比特填充法：给一个固定的帧头帧尾(`01111110`)，并通过打断连续的 `1` 来避免数据和帧头帧尾重复：
	冲突解决方法：
		当遇到连续的5个 `1` 时就会向其中添加一个 `0` ，以避免和帧头帧尾重复。
4. 违规编码法：例如当使用曼彻斯特编码等编码方式时，使用违规的编码来当做定界符。如局域网的 `IEEE 802.11` 标准就采用了此方法。
	具体实现(以曼彻斯特编码为例)：
		曼彻斯特编码规定 `前高后第表示1，前低后高表示0(或反之)` ，则可以使用 `前高后高` 、 `前低后低` 当做定界符。

### 3.1.4 流量控制和可靠传输

<font color="#c00000">流量控制同时负责流量控制和可靠传输</font>。
链路层的流量控制主要依靠于接收方的应答机制，接收方来不及接收时无应答。
流量控制的方法主要有：
1. <font color="#9bbb59">停止-等待协议</font>(可以认为是窗口大小为1的滑动窗口协议)：每发送完一个帧就停止发送，直到接收方确认后再继续发送。
	![[Pasted image 20240304161222.png]]
	缺点：传输效率低
2. <font color="#9bbb59">滑动窗口协议</font>：每个窗口有固定大小，窗口内的帧可以不等待接收方的确认信息连续发送，当发送方每收到一个确认回应，窗口就会往前移动一格。<font color="#c00000">链路层的窗口大小在整个发送过程中固定不变</font>。
	1. 后退N帧协议(GBN)
	2. 选择重传协议(SR)

基本概念：
- <font color="#9bbb59">信道利用率</font>：发送方在整个发送周期内，有效发送数据的时间占整个发送周期的比率：$$\frac{\frac{T时间内发送的数据长度L}{发送方的数据传输率}}{发送周期T}$$
- <font color="#9bbb59">信道吞吐率</font>：$$信道吞吐率=信道利用率\times 发送方的发送速率$$

#### 3.1.4.1 停止-等待协议

在讨论停止等待协议时，通常把网络认为是半双工模型，即发送和接收只能间隔执行。
差错主要可以分为：
1. 帧丢失或帧出错
	对于帧丢失或帧出错，则主要依靠发送方的超时计时器完成，当超过预定的时间没有收到 `ACK` 回应时则自动启动重传机制。通常超市计时器的最长时长会大于平均RTT。
	![[Pasted image 20240305150206.png]]
2. `ACK` 丢失
	对于 `ACK` 丢失，发送方会再次发送对应帧，但是接收方在收到重复帧后会丢弃重复帧并重传对应的 `ACK` 。
	![[Pasted image 20240305150602.png]]
3. `ACK` 迟到
	类似于情况2的操作。当发送方收到重复的 `ACK` 后会丢弃该 `ACK` 。
	![[Pasted image 20240305150816.png]]


具体机制：
1. 发送完一个帧后，发送方必须保存一个副本，只有当收到 `ACK` 回应后才会将其删除。
2. 数据帧和确认帧必须编号，以解决帧重复问题。

优点：
1. 简单

缺点：
1. 信道利用率低

#### 3.1.4.2 后退N帧协议(GBN)

具体机制：
1. 发送方的发送窗口大小为 `N` ，同时发送 `N` 帧；<span style="background:#fff88f"><font color="#c00000">接收方的接收窗口为</font></span> `1` 。
2. <font color="#c00000">接收方在接收完前</font> `k` <font color="#c00000">帧时会返回第</font> `k` <font color="#c00000">帧的</font> `ACK` ，将自己的接收窗口移动到 `K+1` 帧的同时并通知发送方将窗口向后移动到 `K+1` 帧。(<font color="#c00000">注意</font> `ACK` <font color="#c00000">是累计确认</font>)
3. <span style="background:#fff88f"><font color="#c00000">接收方只接收当前接收窗口的帧</font></span><font color="#c00000">，即使收到窗口后续位置的帧也会被接收方丢弃</font>。

其中，发送方需要响应的事件有：
1. 响应上层的调用，如果缓存区域已满则通知上层等待。
2. 响应接收方的 `ACK` 。
3. `ACK` 响应超时，当 `ACK` 响应超时时，<font color="#c00000">发送方会重新发送所有已发送但未被确认的帧</font>。

接收方需要处理的事情有：
1. 如果正确<span style="background:#fff88f"><font color="#c00000">按序</font></span>收到 `n` 号帧，那么将返回 `n` 号帧对应的 `ACK` 给发送方。
2. 如果收到的是非窗口帧，则返回窗口前一帧的 `ACK` (并用此 `ACK` 将窗口帧号同步给发送方)。(窗口帧号会存入 `expectedseqnum`)

注意：
1. <span style="background:#fff88f"><font color="#c00000">接收方只按序接收</font></span>
2. <span style="background:#fff88f"><font color="#c00000">接收方只会累计确认</font></span>
3. <font color="#c00000">如果接收方收到非顺序帧，则会返回前一帧的</font> `ACK` 。
4. 发送窗口大小一般等于$$2^{n-1}$$

大致流程：
	![[Pasted image 20240305154657.png]]

优点：
1. 使用连续发送从而提高了信道利用率。
缺点：
1. 会丢弃正确但是顺序不对的帧，使传输效率降低。

#### 3.1.4.3 选择重传协议(SR)

具体机制：
1. 发送方的发送窗口大小为 `N` ，同时发送 `N` 帧；<span style="background:#fff88f"><font color="#c00000">接收方的接收窗口也为</font></span> `N` (发送窗口一般等于接收窗口)。
2. 设置单个确认机制，只选择错误帧重传。
3. 发送端只有前面的帧都被确认后才会移动窗口。

发送方必须响应的事件：
1. 响应上层的调用，如果缓存区域已满则通知上层等待。
2. 响应接收方的 `ACK` ，并将对应窗口标记为已接收，并检查是否需要移动窗口。
3. `ACK` 响应超时，<font color="#c00000">每个帧都有自己的定时器</font>，<span style="background:#fff88f"><font color="#c00000">一个超时事件发生后只重传一个帧</font></span>。

接收方需要处理的事情有：
1. 对于接收窗口内的帧来者不拒并响应 `ACK` ，如果收到了小于窗口下界的会相应对应 `ACK` ，其他情况会忽略该帧。
2. 当一个连续的帧序列接收完毕后，滑动窗口并将已接收的帧返回给上层。

注意：
1. <span style="background:#fff88f"><font color="#c00000">对每一个帧都设置单个确认机制，收到一个确认一个</font></span>。
2. <font color="#c00000">只重传错误帧</font>。
3. <font color="#c00000">接收方有缓存帧</font>。
4. 发送窗口的大小和接收窗口的大小应当相等，且等于$$2^{n-1}$$

### 3.1.5 差错控制

通常来说，传输过程中的差错都是由于噪声所引起，而噪声可以简单分类为如下两种：
1. <font color="#9bbb59">全局性噪声</font>：由于线路电气特性所带来的随机噪声(热噪声)，一般通过提高信噪比来减少干扰。
2. <font color="#9bbb59">局部性噪声</font>：由于外界特定的短暂原因所造成的冲击噪声，<font color="#c00000">是差错产生的主要原因</font>。主要通过编码技术来解决。

差错主要分为：
1. <font color="#9bbb59">位错</font>：比特位出错。
2. <font color="#9bbb59">帧错</font>：帧丢失、帧重复、帧失序。可以使用对帧编号、确认重传机制等处理(<font color="#c00000">前提是使用有确认的服务</font>)。

位错的解决方法有：
1. 检错编码：
	1. 奇偶校验码
	2. 循环冗余码(CRC)，<font color="#c00000">普遍使用此方式</font>。
2. 纠错编码，例如海明码。

#### 3.1.5.1 检错编码

<font color="#9bbb59">奇偶校验码</font>：
	前 `n-1` 位为信息源，最后一位表示序列中 `1` 的数量的奇偶。

<font color="#9bbb59">循环冗余码(CRC)</font>：
	计算循环冗余码需要提供 `原数据` 和 `生成多项式` 参数，对原数据进行补位，随后对 `生成多项式` 进行 `模二` 取余，即可得CRC校验码。

CRC校验码的计算步骤：
例如给定：
1. 原数据： `101001`
2. 生成多项式： `1101` 或：$$x^3+x^2+0x+1x^0$$(本质等价，见注1)
则有如下运算：
1. 生成多项式的有效长度为<font color="#c00000">4</font>，故对原数据后补<font color="#c00000">3</font>个 `0` ，即： `101001000` 。(因为生成多项式中 `x` 最高阶为<font color="#c00000">3</font>)。
2. 对 `101001000000` 进行 `1101` 的 `模二` 除法(<font color="#c00000">即异或除法</font>)：
	1. 先对从左往右第4位的商处填 `1` ,并对前4位 `1010` 和 `1101` 进行异或算法，得 `111` ：
		![[Pasted image 20240304150024.png]]
		
	2. 将第5位 `0` 补位得 `1110` ，并继续对 `1101` 进行 `模二` 除法，有：
		![[Pasted image 20240304150312.png]]
	3. 循环往复处理到最后一位有：
		![[Pasted image 20240304150334.png]]
	4. 则可得最终余数为 `1` ，即CRC的FCS，最终结果为 `101001001` <font color="#c00000">并发送给接收方</font>。
	5. 接收方验证 `101001001` 对 `1101` 进行 `模二` 运算，如果为0，则验证成功。

<span style="background:#fff88f"><font color="#c00000">CRC校验的发送方和接收方均由硬件实现该过程，不用担心校验速度</font></span>。使用CRC校验的通过校验的帧有<span style="background:#fff88f"><font color="#c00000">接近为1的概率</font></span>没有出现差错。

注：
1. 生成多项式有两种表达式，即：
	`1101` 和：$$x^3+x^2+0x+1x^0$$
	等价。

#### 3.1.5.2 纠错编码

检错编码只能检查错误的发生而无法纠正错误，故有了同时可以检错和纠错的纠错编码，例如海明码。

基本概念：
- <font color="#9bbb59">海明距离</font>(汉明距离)：对于两串等长数据，其相同位置不同的bit位的数量即为海明(汉明)距离，例如：
	- `11001`
	- `00111`
	的海明距离为 `4` 。
- 编码系统的海明距离(<font color="#9bbb59">码距</font>)：对于一个有效编码集，其任意两个元素见最短的汉明距离即为该编码的码距。例如编码集：
	- `000`
	- `001`
	- `010`
	- `...`
	的码距就为1，而编码集：
	- `0000`
	- `1001`
	- `1010`
	- `...`
	的码距就为2。

做以下讨论：
1. 码距为1的编码系统能否发现错误?(不能)
2. 码距为2的编码系统能否发现错误?(可以，如果bit只变了一位，则就可以发现错误)
3. 码距为n的编码系统最多可以检测出有多少bit错误的编码?(n-1位)
4. 码距为3的编码系统最多可以<font color="#c00000">纠正</font>多少位的bit错误?(2位)
5. 如果要<font color="#c00000">检测</font>最多为n位bit的错误，则码距至少为多少?(n+1)
6. 如果要<font color="#c00000">纠正</font>最多为n位bit的错误，则码距至少为多少?(2n+1)

基于以上讨论，对于信息数据 `m` 位，校验码 `r` 位，有效位数为 `m+r` 位的编码，只用校验码可以表示出多少种错误? `m+r` 有效位的编码能发生多少种错误?
- 校验码可以表示的错误种类数为：$$2^r$$
- `m+r` 有效位的编码能发生的错误种类数为：$$m+r$$
故有<font color="#c00000">海明不等式</font>：
$$2^r\geq m+r+1$$
<span style="background:#fff88f"><font color="#c00000">该公式可以确定海明码的位数</font></span>，有了理论基础，则海明码具体编码过程如下：
1. <font color="#c00000">利用海明不等式确定海明码的位数</font>，例如待编码的数据位为4，则有：$$2^r\geq 4+r+1$$
	则有满足要求的解 `r>=3` ，<span style="background:#fff88f"><font color="#c00000">可以满足带编码位数为4的海明码的位数为 <code>m+r=7</code> 位</font></span>。
2. <span style="background:#fff88f"><font color="#c00000">将7位编码中2的n次幂的位置留下当做校验码位</font></span>，余下当做数据位

| 位号    |  7  |  6  |  5  |     4      |  3  |     2      |     1      |
| ----- | :-: | :-: | :-: | :--------: | :-: | :--------: | :--------: |
| **值** |     |     |     | 校验位$$2^2$$ |     | 校验位$$2^1$$ | 校验位$$2^0$$ |
3. 填充数据位(例如给定数据 `1101` )：

| 位号    |               7                |               6                |               5                |     4      |               3                |     2      |     1      |
| ----- | :----------------------------: | :----------------------------: | :----------------------------: | :--------: | :----------------------------: | :--------: | :--------: |
| **值** | <font color="#c00000">1</font> | <font color="#c00000">1</font> | <font color="#c00000">0</font> | 校验位$$2^2$$ | <font color="#c00000">1</font> | 校验位$$2^1$$ | 校验位$$2^0$$ |
4. 规定在2的n次幂的位置的校验位负责管理非n位的校验，例如：

| 位号                                       |               7                |               6                |               5                |     4      |               3                |     2      |     1      |
| ---------------------------------------- | :----------------------------: | :----------------------------: | :----------------------------: | :--------: | :----------------------------: | :--------: | :--------: |
| **二进制位号**                                |              111               |              110               |              101               |    100     |              011               |    010     |    001     |
| **值**                                    | <font color="#c00000">1</font> | <font color="#c00000">1</font> | <font color="#c00000">0</font> | 校验位$$2^2$$ | <font color="#c00000">1</font> | 校验位$$2^1$$ | 校验位$$2^0$$ |
| **<font color="#c00000">校验位管理区域</font>** |                                |                                |                                |   `1**`    |                                |   `*1*`    |   `**1`    |
则有：
- 位号为4的校验位负责管理二进制位号为 `1**` 的数据位的校验，即管理7、6、5、4位
- 位号为2的校验位负责管理二进制位号为 `*1*` 的数据位的校验，即管理7、6、3、2位
- 位号为1的校验位负责管理二进制位号为 `**1` 的数据位的校验，即管理7、5、3、1位
5. 填写每个校验位，使得每个校验位管理区域之和为偶数(或奇数)，即：

| 位号        |               7                |               6                |               5                |  4  |               3                |  2  |  1  |
| --------- | :----------------------------: | :----------------------------: | :----------------------------: | :-: | :----------------------------: | :-: | :-: |
| **二进制位号** |              111               |              110               |              101               | 100 |              011               | 010 | 001 |
| **值**     | <font color="#c00000">1</font> | <font color="#c00000">1</font> | <font color="#c00000">0</font> |  0  | <font color="#c00000">1</font> |  1  |  0  |
6. 即可得对应数据的海明码 `1100110` 。

校验过程：
1. 假如接收方收到的数据为： `1110110`
2. 验算4号校验码：$$x_4=1+1+1+0=1$$
3. 验算2号校验码：$$x_2=1+1+1+1=0$$
4. 验算1号校验码：$$x_1=1+1+1+0=1$$
5. 将各校验码按照如下拼接：$$(x_4)(x_2)(x_1)=101=5$$
6. 故错误位置为5，原海明码为 `1100110` 。

## 3.2 介质访问控制

链路层数据传输链路通常有两种：
1. <font color="#9bbb59">点对点链路</font>：两个节点通过一个链路介质相连，例如广域网的PPP协议。
2. <font color="#9bbb59">广播式链路</font>：所有主机共享通信介质，例如无线局域网等。该链路的典型拓扑结构有总线型和星型。

而介质访问控制主要就是解决广播式链路的通信可能发生互相干扰的情况。其主要有两种：
1. <font color="#9bbb59">静态划分信道</font>，一般使用信道划分介质访问控制，主要有：
	1. 频分多路复用(FDM)
	2. 时分多路复用(TDM)
	3. 波分多路复用(WDM)
	4. 码分多路复用(CDM)
2. <font color="#9bbb59">动态划分信道</font>，主要有：
	1. <font color="#9bbb59">轮询介质访问控制</font>，主要是令牌传递协议
	2. <font color="#9bbb59">随机介质访问控制</font>，主要有：
		1. ALOHA协议
		2. CSMA协议
		3. <font color="#c00000">CSMA/CD协议</font>
		4. <font color="#c00000">CSMA/CA协议</font>

### 3.2.1 信道划分控制协议

主要依靠对<font color="#c00000">时域</font>、<font color="#c00000">频域</font>资源的合理划分(即多路复用技术)来控制对应的网络设备。

频分多路复用(FDM)：
- 将频带分配给所有用户进行使用
- 优点：
	- 技术成熟、实现简单
	- 系统效率较高
- 频分多路复用类似于 `并行` ，时分多路复用类似于 `并发` 。

时分多路复用(TDM)：
- 将一个周期(TDM帧)划分为多个时间片分配给所有用户进行使用
- 缺点：
	- 每个设备只能使用每个周期中固定的时间片的时间(即使其他设备空闲)，会造成信道利用率低，改进方法为统计时分多路复用(STDM)。
- 频分多路复用类似于 `并行` ，时分多路复用类似于 `并发` 。
- 注：
	1. TDM帧是物理层上的时间片，并非链路层的帧。
	![[Pasted image 20240305171232.png]]


统计时分多路复用(STDM)：
	设计如下的逻辑结构：
	![[Pasted image 20240305171830.png]]
	将若干设备传送来的数据缓存入集中器的缓存中，集中器再将数据划分打包为STDM帧进行发送。
- 注：
	1. STDM帧是物理层上的时间片，并非链路层的帧。
	2. STDM帧对设备来说并非固定分配时间片，而是按需分配，信道利用率高。
	3. 相较于TDM的固定分配带宽(无法完全占用信道)，STDM可以使设备达到最大通信速率。

波分多路复用(WDM)：
	波分多路复用就是光的频分多路复用
	![[Pasted image 20240305172349.png]]

码分多路复用(CDM)：
- 通过数学上的运算将若干台设备的数据使用自身序列号按一定规则编码，接收设备可以按照对应规则解析出特定发送设备所发送的值。
- 例如CDMA码分多址规则：
	- 假设发送端A、B分别被指定了一个8位的芯片序列 `00011011` 、 `11010001` ，且保证将序列中的 `0` 置换为 `-1` 后，<font color="#c00000">所有序列两两正交</font>。即A的 `-1 -1 -1 1 1 -1 1 1` 和B的 `1 1 -1 1 -1 -1 -1 1` 正交。(则8位的序列一共有8个两两正交的序列)
	- 随后当设备发送bit `0` 时，发送序列中的 `0` 置换为 `-1` 后的负码；发送bit `1` 时，发送发送序列中的 `0` 置换为 `-1` 后的码。例如：
		- 设备A发送bit `0` ，则发送 `1 1 1 -1 -1 1 -1 -1` 。
		- 设备A发送bit `1` ，则发送 `-1 -1 -1 1 1 -1 1 1` 。

### 3.2.2 动态分配信道

动态分配信道的特点是信道并非在用户通信时固定分配给用户的。

#### 3.2.2.1 [TODO]轮询访问介质控制



#### 3.2.2.2 随机访问介质控制

随机访问介质控制的所有用户可以随时发送信息，发送信息时也可以占用全部带宽。其实现方式主要有：
1. ALOHA协议
2. CSMA协议
3. <font color="#c00000">CSMA/CD协议</font>
4. <font color="#c00000">CSMA/CA协议</font>

##### 3.2.2.2.1 ALOHA协议

ALOHA协议可以分为纯ALOHA协议和时隙ALOHA协议。

纯ALOHA协议：
	不监听信道，不按时间槽(将时间分为一个个等距时间片就叫时间槽)发送，随机重发；当发生冲突时，接收方不发送确认帧，当发送方等待确认帧超时后就可判定发生冲突，随后等待<span style="background:#fff88f"><font color="#c00000">随机时间</font></span>后重传。
	![[Pasted image 20240310192204.png]]

时隙ALOHA协议：
	将时间划分为若干时间片，所有用户在开始时同步时间片，随后按照时间槽发送数据
	![[Pasted image 20240310192535.png]]

特点：
1. 纯ALOHA协议比时隙ALOHA协议吞吐量低，效率也更低。
2. 纯ALOHA想发就发，不用遵循时间槽，而时隙ALOHA需要。

##### 3.2.2.2.2 CSMA协议

CSMA协议全称为 `Carrier Sense Multiple Access` ，即载波监听多路访问协议。
- `Carrier Sense` 载波监听，在每一个站点发送数据前都要检查一下总线上是否有其他计算机在发送数据。
- `Multiple Access` 多点接入，多个计算机连接到一个总线上。

协议思想：
	先监听信道是否空闲(通过检测总线上的电压摆动值)，当信道空闲时发送完整帧，信道忙时推迟发送。根据信息发送的规则可以分为 `1-坚持CSMA` 、 `非坚持CSMA` 、 `p-坚持CSMA` 。

**1-坚持CSMA**：
1. 当信道忙时则一直监听，直到空闲时马上传输。
2. 当冲突发生时，则等待一个随机长的时间后再次监听并尝试发送。

优点：
1. 只要信道空闲就可以立即发送，避免了传输媒体利用率的浪费。

缺点：
1. 当有两个或两个以上的站点在等待信道空闲时，则无可避免的发生冲突。

**非坚持CSMA**：
1. 当信道忙时则等待随机长的时间后再次进行监听，若空闲则立刻传输。

优点：
1. 采用随机的等待时间减少了冲突发生的可能性。

缺点：
1. 可能造成所有设备都在等待的情况，造成媒体利用率的降低。

**p坚持CSMA**：
1. 当信道空闲时以概率 `p` 排定发送数据，概率 `1-p` 判定等到下一个时间槽再发送。
2. 当信道忙时则等到信道闲时在进行上述判定。

优点：
1. 既能像 `1-坚持` 那样减少媒体空闲率，也能像 `p-坚持` 那样减少冲突。

三种方法对比如下：
	![[Pasted image 20240310195156.png]]

<span style="background:#fff88f"><font color="#c00000">但是上述三种CSMA算法均无法做到在发送数据时就知晓冲突发生了的</font></span>，都会将数据坚持发送完毕并等待超时才会知晓，造成了浪费。

##### 3.2.2.2.3 [TODO]CSMA/CD协议

##### 3.2.2.2.4 [TODO]CSMA/CA协议


## 3.3 局域网

### 3.3.1 局域网的基本概念和体系结构

基本概念：
- <font color="#9bbb59">局域网</font>(<font color="#9bbb59">LAN</font>，<font color="#9bbb59">Local Area Network</font>)：某一区域内由多台计算机互联组成的计算机组，<font color="#c00000">使用广播通信</font>。

特点：
1. 覆盖区域小
2. 一般会铺设专用的通信介质(无线局域网除外)
3. 数据传输速率高，通信延迟低，误码率低，可靠性高

局域网介质访问控制方法：
1. CSMA/CD，常用于总线型局域网，也用于树形网络
2. 令牌总线，常用于总线型局域网，也用于树形网络
3. 令牌环，

## 3.7

