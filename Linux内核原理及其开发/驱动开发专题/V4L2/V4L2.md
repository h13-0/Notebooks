---
number headings: auto, first-level 2, max 6, 1.1
---
## 1 目录

```toc
```

## 2 V4L2用户态开发

### 2.1 V4L2用户态开发概述

与V4L2相关的文件系统节点主要有 `/dev/mediax` 、 `/dev/v4l-subdevx` 、 `/dev/videox` ，其主要区别如下：
- `/dev/mediax` ：媒体控制器节点


V4L2可以提供统一的ioctl的命令等参数

### 2.2 基础V4L2操作

#### 2.2.1 打开设备节点

和普通字符设备一样，使用Linux操作摄像头时，第一步依旧是打开摄像头对应的文件节点。

```C
#include <fcntl.h>
#include <stdio.h>

int fd = open(device, O_RDWR);  
if(fd < 0) {  
    printf("open device: %s failed.\r\n", device);  
}
```

#### 2.2.2 查询设备能力

一些设备往往能够同时输出不知一种数据类型，例如一个电视采集卡可以将有线电视的信号转化为linux的音视频输入：
	![[Pasted image 20250326133304.png]]

而当我们想要确认该设备是否有需要的输出能力、或可能需要该设备同时输出多种数据类型时，就需要查询设备能力( `capability` )从而做进一步判断。
查询API为：

```C
#include <sys/ioctl.h>
struct v4l2_capability cap = { 0 };  
int ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);  
if(ret < 0) {  
    printf("get v4l2_capability failed");  
}
```

参考查询结果：
	![[Pasted image 20250325165307.png]]

上述查询结果可以按照如下方式使用：

```C
#include <sys/ioctl.h>
struct v4l2_capability cap = { 0 };  
int ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);  
if(ret < 0) {  
    printf("get v4l2_capability failed.\r\n");  
}

if (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)  
    printf("Support video capture.\r\n");  
  
if (cap.capabilities & V4L2_CAP_AUDIO)  
    printf("Support audio input.\r\n");  
  
if (cap.capabilities & V4L2_CAP_RADIO)  
    printf("Support radio input.\r\n");

...
```

#### 2.2.3 枚举输出格式

在V4L2中，获取一个设备支持的所有输出格式需要依靠类似于遍历的方法实现(该方法被称为枚举、Enumeration)，其示例如下：

```C
struct v4l2_fmtdesc fmtdesc = { 0 };
fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
//fmtdesc.index = 0;
while (1) {
    ret = ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc);
    if (ret == 0)
    {
        // 输出获取到的格式列表
        printf("-----------------------------------------------\r\n");
        printf("fmtdesc.index=%d\r\n", fmtdesc.index);
        printf("fmtdesc.type=%d\r\n", fmtdesc.type);
        printf("fmtdesc.flags=%d\r\n", fmtdesc.flags);
        printf("fmtdesc.description=%s\r\n", fmtdesc.description);
        printf("fmtdesc.pixelformat=%x\r\n", fmtdesc.pixelformat);
    } else if (ret != - EINVAL) {
        printf("enumeration end.\r\n");
        break;
    } else {
        printf("exec ioctl(fd, VIDIOC_ENUM_FMT) failed with ret EINVAL.\r\n");
        break;
    }
    fmtdesc.index ++;
}
```

注：
- 该API的文档可见[7.14. ioctl VIDIOC_ENUM_FMT — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/vidioc-enum-fmt.html)。

示例输出为：

```text
-----------------------------------------------
fmtdesc.index=0
fmtdesc.type=1
fmtdesc.flags=0
fmtdesc.description=32-bit BGRA/X 8-8-8-8
fmtdesc.pixelformat=34524742
-----------------------------------------------
fmtdesc.index=1
fmtdesc.type=1
fmtdesc.flags=0
fmtdesc.description=32-bit A/XRGB 8-8-8-8
fmtdesc.pixelformat=34424752
-----------------------------------------------
fmtdesc.index=2
fmtdesc.type=1
fmtdesc.flags=0
fmtdesc.description=24-bit BGR 8-8-8
fmtdesc.pixelformat=33524742
-----------------------------------------------
fmtdesc.index=3
fmtdesc.type=1
fmtdesc.flags=0
fmtdesc.description=24-bit RGB 8-8-8
fmtdesc.pixelformat=33424752
...
```

#### 2.2.4 枚举指定输出格式的分辨率

与枚举输出格式类似，枚举分辨率也需要进行类似的操作，其需要指定：
- `frame_size.pixel_format` ：要查询的目标格式
且需要注意Linux支持如下三种分辨率步进方式：
1. 离散分辨率，即设备只支持几个特定的离散分辨率。
	- 此时  `frame_size.type=V4L2_FRMSIZE_TYPE_DISCRETE` 。
	- 此时该 `ioctl` 操作需要多次枚举，每次会得到一个离散分辨率。
2. 连续分辨率，设备支持在该分辨率范围内任意指定。
	- 此时 `frame_size.type=V4L2_FRMSIZE_TYPE_CONTINUOUS` 。
	- 通常只需要一次枚举。
3. 步进分辨率，设备只能在该分辨率范围内步进选择。
	- 此时 `frame_size.type=V4L2_FRMSIZE_TYPE_STEPWISE` 。
	- 在不同长宽比例下需要多次枚举。

示例程序：

```C
void enum_frame_size(int fd, uint32_t format)
{
    struct v4l2_frmsizeenum frame_size = { 0 };
    frame_size.pixel_format = format;
    int ret = 0;
    while (1)
    {
        ret = ioctl(fd, VIDIOC_ENUM_FRAMESIZES, &frame_size);
        if (ret == 0)
        {
            switch (frame_size.type) {
                case V4L2_FRMSIZE_TYPE_DISCRETE:
                    // 设备支持的帧尺寸是离散的
                    printf("frame_size.type=V4L2_FRMSIZE_TYPE_DISCRETE\r\n");
                    printf("frame_size.discrete.width=%d\r\n", frame_size.discrete.width);
                    printf("frame_size.discrete.height=%d\r\n", frame_size.discrete.height);
                    break;

                case V4L2_FRMSIZE_TYPE_CONTINUOUS:
                    // 设备支持连续的帧尺寸范围
                    printf("frame_size.type=V4L2_FRMSIZE_TYPE_CONTINUOUS\r\n");
                    printf("frame_size.stepwise.min_width=%d\r\n", frame_size.stepwise.min_width);
                    printf("frame_size.stepwise.max_width=%d\r\n", frame_size.stepwise.max_width);
                    printf("frame_size.stepwise.step_width=%d\r\n", frame_size.stepwise.step_width);
                    printf("frame_size.stepwise.min_height=%d\r\n", frame_size.stepwise.min_height);
                    printf("frame_size.stepwise.max_height=%d\r\n", frame_size.stepwise.max_height);
                    printf("frame_size.stepwise.step_height=%d\r\n", frame_size.stepwise.step_height);
                    break;

                case V4L2_FRMSIZE_TYPE_STEPWISE:
                    // 设备支持的帧尺寸在一个范围内，并且可以按特定步长进行调整
                    printf("frame_size.type=V4L2_FRMSIZE_TYPE_STEPWISE\r\n");
                    printf("frame_size.stepwise.min_width=%d\r\n", frame_size.stepwise.min_width);
                    printf("frame_size.stepwise.max_width=%d\r\n", frame_size.stepwise.max_width);
                    printf("frame_size.stepwise.step_width=%d\r\n", frame_size.stepwise.step_width);
                    printf("frame_size.stepwise.min_height=%d\r\n", frame_size.stepwise.min_height);
                    printf("frame_size.stepwise.max_height=%d\r\n", frame_size.stepwise.max_height);
                    printf("frame_size.stepwise.step_height=%d\r\n", frame_size.stepwise.step_height);
                    break;

                default:
                    break;
            }
        } else if (ret != - EINVAL) {
            printf("frame size enumeration end.\r\n");
            break;
        } else {
            printf("exec ioctl(fd, VIDIOC_ENUM_FRAMESIZES) failed with ret -EINVAL.\r\n");
            break;
        }
        frame_size.index ++;
    }
}
```

示例输出如下：

```text
frame_size.type=V4L2_FRMSIZE_TYPE_CONTINUOUS
frame_size.stepwise.min_width=2
frame_size.stepwise.max_width=8192
frame_size.stepwise.step_width=1
frame_size.stepwise.min_height=1
frame_size.stepwise.max_height=8192
frame_size.stepwise.step_height=1
frame size enumeration end.
```

#### 2.2.5 设置指定的视频格式和分辨率




## 3 V4L2内核态开发

### 3.1 V4L2内核态开发概述








V4L2提供了如下的接口：
- 视频采集接口
- 视频输出接口
- 直接传输视频接口
- 视频间隔消隐信号接口
- 收音机接口

V4L2的原码位于 `drivers/media/v4l2-core` 目录下



V4L2设备的注册流程通常为：
1. 定义设备注销时资源释放回调和 `v4l2_device` 结构体
2. 检查设备类型并确定设备节点基本名称
3. 设置设备类型、次设备号及设备节点数量
4. 将 `video_device` 结构体指针保存到全局 `video_device` 数组中
5. 根据设备类型验证哪些 `ioctl` 函数可以使用
6. 分配字符设备结构体
7. 设置字符设备的操作函数集合 `v4l2_fops`
8. 将video设备注册到字符设备
9. 设置设备引用计数为0时的回调函数
10. 增加 `video_device` 所属的 `v4l2_device` 的引用计数
11. 设置已注册标志 `V4L2_FL_REGISTERED`

