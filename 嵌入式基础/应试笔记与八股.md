---
number headings: auto, first-level 2, max 6, 1.1
---
#嵌入式 #应试笔记与八股 

## 1 目录

```toc
```

## 2 通用嵌入式基础

### 2.1 基础硬件协议或结构

#### 2.1.1 综述类

##### 2.1.1.1 串口、I2C、SPI之间的相同点和不同点

考察企业：
- 海康威视

1. 这三个都是嵌入式系统中常用且基础的设备间的硬件通信协议，其相同点主要有：
	1. 这三个通信协议都用于设备之间的数据传输
	2. 这三个通信协议所需要的例如电气性能、引脚数量等硬件要求相比于以太网、USB等协议低
	3. 这三个协议都是非差分走线的串行协议
	4. 应用极为广泛，基本上所有的单片机及SoC都会硬件原生支持这些协议
2. 这三个协议的不同点主要有以下几个方面：
	1. 硬件引脚定义、连接方式、接线数量不同：
		1. 串口可以分为异步串口(UART)和同步串口(USART)两种，这两种的根本区别在于是否有一个独立的时钟线(CLK)同步两个设备之间的时钟信号。而异步串口最少需要2根引脚才能完成双向通信，同步串口则至少需要三根。此外这两种串口都有可选的两个流控引脚(CTS/RTS)。
		2. I2C使用一个数据引脚(SDA)和一个时钟引脚(SCL)进行数据传输
		3. SPI至少需要MISO、MOSI、SCK三个引脚才能完成单主从之间的双向通信，若需要单主多从的通信则需要额外的片选引脚(CS)。此外，若只需要单向的主向从通信，则可以省略MISO。
		4. 当然这些通信协议均需要相同的GND作为电平参考
	2. 通信模式不同：
		1. 串口最多支持全双工模式
		2. SPI最多支持全双工模式
		3. I2C最多支持<font color="#c00000">半双工</font>模式
	3. 通信拓扑结构不同：
		1. 串口往往用于一主一从的全双工通信模式，当且仅当在处理好波特率、数据包解析与异常处理时才能考虑一发多收的单向通信模式。后者往往不建议使用。
		2. I2C支持一主多从模式，在8位地址的模式下，通常读地址和写地址分别占用同一个高七位地址，并用最后一位区分是读地址还是写地址。通常来说，写地址最低位为0，读地址最低位为1。在这种模式下，通常一个主设备下可以外挂128个从设备。主设备不占用地址。
		3. SPI支持一主多从模式，其使用CS片选信号来选定需要通信的设备。
	4. 通信速率不同：
		1. 串口往往使用9600、115200bps等常用速率，但部分平台也原生支持自定义通信速率。
		2. I2C的标准模式下通信速率为100Kbps，快速模式下通信速率为400Kbps。
		3. SPI的具体速率往往没有约定成俗，最快速率取决于主设备和从设备。比如ESP32最高为80Mbps，ST7789V屏幕控制芯片的最高速率为50Mbps。
	5. 可靠性和错误处理不同：
		1. 串口有奇偶校验位，在波特率等设置正确的情况下，一定程度上可以避免传输错误

##### 2.1.1.2 讲一下串口和并口的区别


##### 2.1.1.3 讲一下在嵌入式系统中，如何管理内存

1. 由于大多数嵌入式MCU并没有集成内存管理单元MMU，或者部分拥有MMU的SoC也并没有提供虚拟内存地址的功能(比如esp32)，因此从硬件上就决定了大多数嵌入式MCU并没有硬件级别的动态内存管理能力，也无法避免动态内存的内存碎片问题。所以在嵌入式系统中，内存管理的方式主要有如下几种：
	1. 使用静态内存，直接将需要操作的内存分配在堆里。
	2. 自行实现或移植一个动态内存管理器，或者直接使用FreeRTOS的堆内存管理等。

#### 2.1.2 IIC协议

##### 2.1.2.1 协议基础

##### 2.1.2.2 IIC时序

考察企业：
- 海康威视
- 荣耀
- 经纬恒润

![[I2C总线标准#2 2 I2C传输的总体流程]]

##### 2.1.2.3 杂项问题

###### 2.1.2.3.1 如果两个IIC设备的地址完全一样应该怎么操作

1. 首先应该查阅数据手册，考虑能否通过软件设置或者引脚配置等方式修改这两个IIC设备的地址，这样是最根本的解决方案。
2. 考虑使用多个I2C总线
3. 考虑使用I2C多路复用器
4. 通过控制从设备的电源或者使能状态来保证数据传输时只有一个设备在工作

#### 2.1.3 SPI协议

##### 2.1.3.1 SPI接口的硬件线路组成及作用

1. 标准SPI是摩托罗拉在1980年左右提出的，其最初的版本即较为常用的标准SPI。其硬件构成为MOSI、MISO、SCK、$\overline{\text{SS}}$四条线路。其中：
	1. MOSI为Master Output Slave Input，主设备输出从设备输入线路
	2. MISO为Msater Input Slave Output，主设备输入从设备输出线路
	3. SCK为Serial Clock，即时钟线路
	4. $\overline{\text{SS}}$为片选线路，低电平有效
	这些电气线路在约定的时钟相位和时钟极性下进行数据传输。
2. 除了标准SPI，还有缺线SPI、3-wire SPI、Dual SPI、Quad SPI等变种SPI。其中：
	1. 缺线SPI是指在MOSI或MISO中缺了一根通信线路的SPI，往往用于单向通信设备，例如ST7789等显示屏。<font color="#c00000">缺线SPI是单向通信</font>。
	2. 3-wire SPI是指将MISO、MOSI合并为同一根电气线路的SPI。因为标准SPI尽管是全双工协议，但是输入输出任务往往交替运行。因此3-wire SPI在省略了一根电气线路时，实际传输速度基本没有受到影响。<font color="#c00000">3-wire SPI是单工通信</font>。
	3. 而Dual SPI、Quad SPI是在3wire SPI的基础上进行改进的，其分别是双复用IO、四复用IO的SPI，分别每次传输2bit和4bit数据。<font color="#c00000">Dual SPI、Quad SPI都是单工通信</font>。

##### 2.1.3.2 从机会主动发送数据吗

考察企业：
- 锦浪

1. SPI




#### 2.1.4 串口协议

##### 2.1.4.1 485有多少根线，功能是什么

1. RS485是串口协议的一种，其与RS232、TTL协议最大的区别是在于物理层定义的电平特性有所不同。但是其本质仍然是串口协议。
2. RS485与RS232、TTL最大的不同是在于RS485使用的是差分线路，其使用了U+和U-两条查分信号对传输差分信号，当U+电压大于U-时表示逻辑1，反之则为逻辑0。
3. 在硬件上，除了U+和U-以外通常还需要一根GND来当做参考电平，减少噪音干扰。其共模电压范围为-7V~+12V。
4. 因此485通常至少要使用3根线，其中两根差分线路组成一个差分对进行数据传输。

##### 2.1.4.2 简述一下485通讯协议以及硬件，485的从机数量有要求吗

考察企业：
- 诺瓦星云
- 经纬恒润

1. RS485是串口协议的一种，其与RS232、TTL协议最大的区别是在于物理层定义的电平特性有所不同。但是其本质仍然是串口协议。
2. RS485与RS232、TTL最大的不同是在于RS485使用的是差分线路，其使用了U+和U-两条查分信号对传输差分信号，当U+电压大于U-时表示逻辑1，反之则为逻辑0。
3. 在硬件上，除了U+和U-以外通常还需要一根GND来当做参考电平，减少噪音干扰。其共模电压范围为-7V~+12V。
4. 由于其只有一对查分信号对，因此其是半双工通信，往往需要应用层通信协议来完成通信。常用的应用层协议是Modbus。
5. 在物理层协议层面，即RS-485协议上，其规定了单位负载下最多支持32个节点，即挂载32个从机。这是从电气负载、电容阻抗、噪声干扰层面进行考虑的。当从设备数量大于32个设备后应当考虑增加中继器。而RS-485设备所使用的Modbus通信协议支持挂载247从设备。

#### 2.1.5 CAN协议




#### 2.1.6 中断

##### 2.1.6.1 讲一下51单片机的中断处理流程

1. 51单片机的中断信号通常是外部IO、定时器触发或者串口等通信协议触发。每个中断源都有对应的中断标志位。
2. 当中断发生时，中断对应的中断标志位会自动被CPU设置，随后CPU检查中断使能位(EA)是否为1，如果为1则会CPU会继续响应，如果不为1则中断请求会被忽略。
3. 随后CPU会检查中断源对应的局部中断使能，当该使能被设置为1时则会继续响应。
4. 随后CPU会判定中断优先级，如果当前CPU并未在终端执行程序，或中断优先级比当前执行的中断优先级高，随后则会响应该中断。
5. 随后CPU会保存上下文信息，包括程序计数器PC等必要寄存器。
6. 随后CPU会查询内存中的中断向量地址，并跳转到对应的地址执行中断服务函数。
7. 当中断服务函数执行完毕后，CPU恢复上下文信息，并继续进行中断发生前的程序。

几个注意事项：
1. 低优先级的中断被高优先级中断打断时，低优先级的中断会被挂起，直到高优先级中断响应完毕。

##### 2.1.6.2 什么是中断优先级，如何设置中断优先级

1. 中断优先级指的是当若干中断同时到来，或者在执行中断函数时触发了别的中断时的嵌套与响应的优先级。
2. 

#### 2.1.7 DMA

##### 2.1.7.1 解释一下DMA的工作原理及其优缺点


#### 2.1.8 ADC

##### 2.1.8.1 讲一下STM32的ADC采样如何配置和使用





### 2.2 单片机基础

#### 2.2.1 单片机上电之后是怎么运行的




#### 2.2.2 单片机上电之后不运行可能的原因是什么

考察企业：

略。

#### 2.2.3 讲一下BSS段

考察企业：
- 深圳百格

1. BSS段指的是C语言程序内存布局中的数据段中的未初始化数据段。
2. 这段由系统进行分配并清零，因此每个程序开始时BSS段中的数据都是0。
3. 而数据段主要存放全局变量和静态变量，其中程序定义了初始值的变量会存放进已初始化的数据段，这部分数据被编译在可执行文件中，并在加载时由系统拷贝。而未定义初始值的变量会存放到BSS段，由于BSS段初始数据为0，因此未设置初值的全局变量和静态变量的值均为0。

### 2.3 基础操作系统类(RTOS、Linux)

#### 2.3.1 综述类

##### 2.3.1.1 FreeRTOS和Linux的区别与相同点

考察企业：
- 海康威视

1. 首先FreeRTOS和Linux都是常用的嵌入式操作系统。相比于裸机，他们所解决的问题集中于多任务处理、开发生态环境等问题上，例如如果需要网络开发，则通常需要LwIP配合多任务调度等，如果需要ROS环境开发则无法离开Linux的支持。并且通常在引入操作系统之后，就可以利用操作系统的一些内存管理或者任务管理等裸机无法实现或难以实现的特性。
2. 而在区别点上，Linux和FreeRTOS主要在于任务需求或硬件资源上进行选择或区分：
	1. 通常来说，FreeRTOS只需要几KB到几十KB的运行内存或储存，但是Linux则需要至少若干兆字节的运储存才能很好的运行。此外，Linux通常需要内存管理器MMU的支持，不然难以解决内存碎片问题。
	2. 在操作系统的特性上，FreeRTOS可以严格地保证任务调度的实时性，但是Linux需要打上实时性内核补丁才能保证较低实时性的任务。
	3. 在操作系统特性上，Linux提供了更多的现代操作系统的特性，例如多用户管理、虚拟内存、网络协议栈、加载内核模块、GUI界面、Shell终端等。

#### 2.3.2 Linux专题

##### 2.3.2.1 如果Linux中的一个进程的某个线程崩溃了，进程会变成什么状态

考察企业：
- 海康威视

1. 在C和C++中，一个进程中的某个线程崩溃时，该进程一定会崩溃并变成"僵尸"状态或"已终止"状态：
	1. 如果一个父进程的子进程的某个线程崩溃时，该子进程被父进程调用 `wait` 或 `waitpid` 回收处理之前会保持僵尸进程状态。
	2. 如果父进程调用了 `wait` 等接口回收了子进程，则该子进程会变成"已终止"状态。这个父进程可以是 `init` 进程或者 `shell` 进程等。
2. 但是在Python和Java等语言中，一个进程中的某个线程崩溃并不一定会导致整个进程崩溃，例如JVM拦截了 `SIGSEGV` (段错误)等信号，从而阻止整个进程崩溃。

##### 2.3.2.2 Linux中的内存命令有哪些

考察企业：
- 海康威视

1. 任务管理器类命令： `top` 、 `htop` 
2. todo

##### 2.3.2.3 Linux的设备和驱动是如何进行匹配的

考察企业：
- 信捷电气

1. 对于非可拔插式设备，其通常会直接定义于设备树中，并参与内核的编译。比如CPU、内存节点、总线、时钟源、GPIO等。设备树在内核启动的时候就会被加载，随后查找驱动程序并尝试匹配。
2. 对于可插拔式设备，比如USB、PCIe设备等，这些设备通常不会被静态的定义于设备树中，但是USB和PCIe的控制器会被定义于设备树中，这些控制器检测新设备的插入并通知系统加载对应的驱动程序。
3. TODO

##### 2.3.2.4 Linux中如果使用malloc申请一片内存，存入数据后释放，这片地址的值会怎么样，程序能否继续读写，数据是否还存在

考察企业：
- 海康威视

1. 在内存被申请释放后，这片内存数据不会立即被清除，这片内存上的数据会存放一段时间直到这片内存对应的物理空间被再次使用。
2. 在这片内存被释放后，该片内存已经不再归程序所有，其数据可靠性不会有任何保障。
3. 在这片内存被申请回收后，指向这片内存的指针会被称作"悬挂指针"，此时如果再去进行读写操作则是未定义行为

#### 2.3.3 FreeRTOS专题

##### 2.3.3.1 FreeRTOS中如何实现任务间通信

1. FreeRTOS中没有进程的概念，所有线程中都可以互相使用对应的内存地址，因此FreeRTOS中任务或线程间的通信可以直接使用普通操作系统中线程通信的方法，比如信号量等。互斥锁本质也是信号量的一种。
2. 此外，FreeRTOS中还支持使用队列进行任务间通信，信息发送者调用对应的信息发送方法，接收者调用接收方法。这两个方法都可能发生阻塞，例如当请求发送时队列已满，或者请求接收时队列已空时均会发生阻塞。不过在调用时都可以设置超时时间。
3. 此外，也可以使用事件进行任务间通信，事件组允许同时发送组内的多个事件。接受者直接使用 `WaitBits` 方法即可等待事件，且该方法允许设置超时时间。
4. 此外还有一些专门用于特殊场合的通信方式，比如使用任务通知 `TaskNotify` ，该方法允许更快地将事件传递到接收者(比信号量、队列、事件组都快)。

##### 2.3.3.2 讲一下FreeRTOS中的队列

1. FreeRTOS的队列主要用于任务间的通信和同步，从而避免了多线程之间的互斥、竞争与同步问题。
2. 其使用步骤是创建队列、发送数据和接收数据。其在创建时需要指定元素大小和元素数量，当队列为空时发出接收数据请求时会被阻塞，当队列满时发出发送数据请求均会被阻塞。其阻塞的最大等待时间可以设置。
3. 需要注意的是，中断中使用这种在普通状态下可能会导致阻塞的接口时，必须使用其对应的中断版本，即 `xxxFromISR` 。中断版本的接口是无阻塞的，因此必须需要注意完善对应的逻辑。

##### 2.3.3.3 FreeRTOS中任务切换的原理

考察企业：
- 联想


##### 2.3.3.4 讲一讲什么是优先级反转，如何解决优先级反转

考察企业：
- TP-Link
- 韶音科技

1. 优先级反转问题指的是高优先级任务被低优先级任务无意间阻塞，从而在现象上表现为 "优先级反转" 。
2. 一个最基本的例子就是某低优先级任务先占用了某个资源但是一直不释放，高优先级任务后申请该资源导致一直被阻塞。这种例子是最简单最核心的例子，但是<font color="#c00000">一般不会直接构成</font>长期持有资源不释放的这种低级错误。
3. 考虑一个间接构成的情况：
	1. 有如下三个任务：
		- 高优先级任务H，需要持有资源A，但是比L后申请。
		- 中优先级任务M，不需要资源，一直就绪。
		- 低优先级任务L，持有资源A，并且就绪。
	2. 则此时CPU会一直执行任务M，就会表现为任务M的优先级比H高。
4. 为了解决这个问题，可以考虑如下的解决方案：
	1. <font color="#c00000">优先级继承</font>：当低优先级任务L需要使用与高优先级任务H共享的资源时，暂时性的将低优先级任务优先级拉到与高优先级相等的优先级，避免被其他中优先级任务中断。
	2. <font color="#c00000">优先级天花板</font>：确保所有任务在尝试获取资源之前先提升到最高的相关优先级，以避免中优先级任务的干扰。(与上一方法本质一直，都是避免中优先级任务打扰)
	3. 尽可能的避免使用共享资源
PS：优先级反转的经典例子就是1997年火星探测器"探路者"号的优先级反转问题。(不用背，了解即可)

##### 2.3.3.5 如何在FreeRTOS中检测和定位内存溢出


##### 2.3.3.6 如何合理地设置任务栈大小

1. 先使用有较大运存的平台进行开发，在开发时给对应任务分配足够多的内存，确保不会出现栈溢出的情况。
2. 在测试时尽可能的触发最复杂的情况，并调用FreeRTOS中的API来监控每个任务使用的最大占空间。
3. 将记录到的最大占空间乘上1.5或2.0作为任务栈大小。

##### 2.3.3.7 前后台系统与实时操作系统的区别是什么









### 2.4 OTA类问题




