---
number headings: auto, first-level 2, max 6, 1.1
---
#面向对象的程序设计

## 1 目录

```toc
```

## 2 面相对象的基本特性

### 2.1 继承


`重载` (`overriding`)的基本释义为子类覆盖父类中的一个实现。

### 2.2 多态

`多态` (`Polymorphism`)是一个希腊词汇，从字面上理解为多种形态。
<span style="background:#fff88f"><font color="#c00000">该特性允许开发者使用相同的接口调用不同的基类方法</font></span>。
其最重要的两个要素为：
1. <font color="#c00000">接口的一致性</font>：通过相同的接口或抽象基类调用方法。
2. <font color="#c00000">行为的多样性</font>：在派生类中实现相同的接口方法，但具有不同的行为。

在上述的定义下，从语言理论上，多态通常有如下的分类：
1. 类型多态
	1. 参数多态：例如使用泛型，允许函数或数据类型在不同数据类型上操作而不必对每种数据类型编写单独的代码。
	2. 包含多态：
2. 接口多态
3. 广义多态
	1. 函数重载
	2. 运算符重载
4. 协变与逆变
	1. 协变：允许一个方法<font color="#c00000">返回</font>比它在父类中声明的方法更具体的类型
	2. 逆变：允许一个方法<font color="#c00000">接收</font>比它在父类中声明的方法更一般的类型作为参数
而从多态解析的时间上进行分类，则有如下的类型：
1. 静态多态
2. 动态多态

接下来将根据如下的C++代码对如上的若干分类进行讨论：

```CPP
#include <iostream>

// 基类
class Animal {
public:
    // 虚函数
    virtual void makeSound() {
        std::cout << "Some animal sound" << std::endl;
    }
    virtual ~Animal() {}  // 虚析构函数，确保删除派生类对象时，能正确调用派生类的析构函数
};

// 派生类 Dog
class Dog : public Animal {
public:
    void makeSound() override {
        std::cout << "Woof" << std::endl;
    }
};

// 派生类 Cat
class Cat : public Animal {
public:
    void makeSound() override {
        std::cout << "Meow" << std::endl;
    }
};

// 函数，接受 Animal 类型的引用
void perform(Animal &animal) {
    animal.makeSound();
}

int main() {
    Dog myDog;
    Cat myCat;

	myDog.makeSound();
	myCat.makeSound();

    perform(myDog);  // 输出 Woof
    perform(myCat);  // 输出 Meow

    return 0;
}

```





### 2.3 组合

