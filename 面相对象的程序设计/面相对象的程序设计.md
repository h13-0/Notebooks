---
number headings: auto, first-level 2, max 6, 1.1
---
#面向对象的程序设计

## 1 目录

```toc
```

## 2 面相对象的基本特性

### 2.1 继承


`重载` (`overriding`)的基本释义为子类覆盖父类中的一个实现。

### 2.2 多态

`多态` (`Polymorphism`)是一个希腊词汇，从字面上理解为多种形态。
<span style="background:#fff88f"><font color="#c00000">该特性允许开发者使用相同的接口调用不同的基类方法</font></span>。
其最重要的两个要素为：
1. <font color="#c00000">接口的一致性</font>：通过相同的接口或抽象基类调用方法。
2. <font color="#c00000">行为的多样性</font>：在派生类中实现相同的接口方法，但具有不同的行为。
该行为主要通过如下两个环节实现：
1. 重写/重载()

从而讨论以下两种情景：

| <center>情景一</center>                                                                                                                                          | <center>情景二</center>                                                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. 先定义 `Animal` 基类，并在基类中定义虚函数 `bark()` 。<br>2. 定义 `Dog` 和 `Cat` 类，并实现(重写、重载) `bark()` 方法。<br>3. 定义变量 `dog` 和 `cat` 。<br>4. 分别调用 `dog.bark()` 和 `cat.bark()` 。 | 1. 先定义 `Animal` 基类，并在基类中定义虚函数 `bark()` 。<br>2. 定义 `Dog` 和 `Cat` 类，并实现(重写、重载) `bark()` 方法。<br>3. 定义变量 `dog` 和 `cat` 。<br>4. 定义函数 `void makeBark(Animal &animal) { animal.bark(); }`<br>5. 分别调用 `makeBark(dog)` 和 `makeBark(cat)` 。 |

在上述两种情况中：
1. 都分别调用了 `Dog` 和 `Cat` 类的 `bark()` 实现。
2. <span style="background:#fff88f"><font color="#c00000">但是情景一通常不认为是多态，情景二才认为是多态</font></span>。
3. 

C++示例代码如下：

```CPP
#include <iostream>

// 基类
class Animal {
public:
    // 虚函数
    virtual void makeSound() {
        std::cout << "Some animal sound" << std::endl;
    }
    virtual ~Animal() {}  // 虚析构函数，确保删除派生类对象时，能正确调用派生类的析构函数
};

// 派生类 Dog
class Dog : public Animal {
public:
    void makeSound() override {
        std::cout << "Woof" << std::endl;
    }
};

// 派生类 Cat
class Cat : public Animal {
public:
    void makeSound() override {
        std::cout << "Meow" << std::endl;
    }
};

// 函数，接受 Animal 类型的引用
void perform(Animal &animal) {
    animal.makeSound();
}

int main() {
    Dog myDog;
    Cat myCat;

    perform(myDog);  // 输出 Woof
    perform(myCat);  // 输出 Meow

    return 0;
}

```

### 2.3 组合

