---
number headings: auto, first-level 2, max 6, 1.1
---
#面向对象的程序设计

## 1 目录

```toc
```

## 2 面相对象的基本特性

### 2.1 类




#### 2.1.1 构造函数

构造函数主要有如下几种类别：
1. 赋值构造函数
2. 复制构造函数
3. 移动构造函数



#### 2.1.2 析构函数





### 2.2 接口

在面相对象的程序设计中，接口可以理解为一个规范或约定。




在C++中并未提供类似于Java中直接给出的 `interface` 关键字，因此在C++中的接口通常使用抽象类实现。具体的接口可以如下定义：

```C++
#include <iostream>
#include <string>

class Animal {
public:
    // 纯虚函数，使 Animal 成为抽象类
    virtual std::string getName() const = 0; // 获取动物的名字
    virtual void setName(const std::string& name) = 0; // 设置动物的名字
    virtual void makeSound() = 0; // 发出声音

    // 虚析构函数，确保派生类的析构函数被调用
    virtual ~Animal() {}
};
```

在Java中，接口可通过如下方式定义：

```Java
public interface Animal {
	String getName();
	void setName(String name);
	void makeSound();
}
```

在上述的若干语言中的代码均定义了一个最基础的 `Animal` "规范"(即接口)，均定义有如下方法：
- 获取名字
- 设置名字
- 制造叫声
随后即可在下一章节中讲述如何实现这些接口。

### 2.3 继承







而在Java中，继承有两种方式：
1. <font color="#c00000">类继承类</font> 或者 <font color="#c00000">接口继承接口</font>：此时应当使用 `extends` 特性。<font color="#c00000">该特性主要用来扩展类的功能</font>。子类继承父类后，除了可以获得父类的属性和方法外，还可以添加新的属性和方法，或者覆盖(Override)父类的方法。
2. <font color="#c00000">类实现接口</font>：此时应当使用 `implements` 特性。<font color="#c00000">当使用该特性时</font>，<span style="background:#fff88f"><font color="#c00000">该类必须实现对应接口的所有方法</font></span>(<font color="#c00000">除非该类被声明为抽象类</font>)。<font color="#c00000">该特性确保了使用implements的非抽象类能满足对应接口所要求的所有行为规范</font>。

`重载` (`overriding`)的基本释义为子类覆盖父类中的一个实现。







### 2.4 多态

`多态` (`Polymorphism`)是一个希腊词汇，从字面上理解为多种形态。
<span style="background:#fff88f"><font color="#c00000">该特性允许开发者使用相同的接口调用不同的基类方法</font></span>。
其最重要的两个要素为：
1. <font color="#c00000">接口的一致性</font>：通过相同的接口或抽象基类调用方法。
2. <font color="#c00000">行为的多样性</font>：在派生类中实现相同的接口方法，但具有不同的行为。

在上述的定义下，从语言理论上，多态通常有如下的分类：
1. 类型多态
	1. 参数多态：例如使用泛型，允许函数或数据类型在不同数据类型上操作而不必对每种数据类型编写单独的代码。
	2. 包含多态：又称为<span style="background:#fff88f"><u>子类型多态</u></span>。这种多态性依赖于继承机制，允许子类类型的对象被视为其父类类型的对象使用，同时保持自己的方法实现。它是动态多态的一种实现方式，主要通过虚函数来实现。
2. 接口多态：接口多态指通过接口的实现，不同的类可以以相同的方式被处理。这是面向对象编程中的核心概念之一，它强调实现特定接口的类必须提供接口声明的所有方法的实现。
3. 广义多态
	1. 函数重载
	2. 运算符重载
4. 协变与逆变
	1. 协变：允许一个方法<font color="#c00000">返回</font>比它在父类中声明的方法更具体的类型
	2. 逆变：允许一个方法<font color="#c00000">接收</font>比它在父类中声明的方法更一般的类型作为参数
而从多态解析的时间上进行分类，则有如下的类型：
1. 静态多态：在编译期间进行多态的解析。
2. 动态多态：在运行时进行多态的解析(通常依赖类中的指针)。

接下来将根据如下的C++代码对如上的若干分类进行讨论：

```CPP
#include <iostream>

// 基类
class Animal {
public:
    // 虚函数
    virtual void makeSound() {
        std::cout << "Some animal sound" << std::endl;
    }
    virtual ~Animal() {}  // 虚析构函数，确保删除派生类对象时，能正确调用派生类的析构函数
};

// 派生类 Dog
class Dog : public Animal {
public:
    void makeSound() override {
        std::cout << "Woof" << std::endl;
    }
};

// 派生类 Cat
class Cat : public Animal {
public:
    void makeSound() override {
        std::cout << "Meow" << std::endl;
    }
};

// 函数，接受 Animal 类型的引用
void perform(Animal &animal) {
    animal.makeSound();
}

int main() {
    Dog myDog;
    Cat myCat;

	myDog.makeSound();
	myCat.makeSound();

    perform(myDog);  // 输出 Woof
    perform(myCat);  // 输出 Meow

    return 0;
}

```

在上述代码中：
1. `Dog` 和 `Cat` 类继承了 `Animal` 类，并重写了 `makeSound` 方法，是<font color="#c00000">类型多态中的包含多态</font>。
2. `myDog.makeSound();` 和 `myCat.makeSound();` ：
	1. 在多态的语言理论上的分类来看是<font color="#c00000">接口多态</font>。
	2. 其多态的解析是在编译时进行的，从解析的时间上进行分类是<font color="#c00000">静态多态</font>。
3. `void perform(Animal &animal);` 、 `perform(myDog);` 以及 `perform(myCat);` ： 
	1. `perform` 方法允许接收比它在父类中声明的方法更一般的类型作为参数(即允许接收 `Dog` 和 `Cat` 类型)，属于<font color="#c00000">逆变</font>。
	2. 在其方法中，多态的解析是在运行时进行的，从解析的时间上进行分类是<font color="#c00000">动态多态</font>。

### 2.5 组合

