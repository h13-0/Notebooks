---
number headings: auto, first-level 2, max 6, 1.1
---
#操作系统

## 1 目录

```toc
```

## 2 概述

## 3 IO模型

在IO模型上，主要可以分为阻塞IO(BIO)、同步非阻塞(NIO)和异步非阻塞(AIO)三种。

基本定义：
- <font color="#9bbb59">阻塞</font>：在进行请求时，若系统不能立即处理或满足该请求，则该线程会被该函数阻塞，直到处理结束或满足该请求。阻塞时该线程通常不会获得处理器时间。
- <font color="#9bbb59">非阻塞</font>：在进行请求时，无论系统能不能立即处理或满足该请求，该函数都一定会立即返回。
- <font color="#9bbb59">同步</font>：在进行一系列请求时，必须按照顺序，在一个请求完成后才可以处理下一个请求的IO模型叫作同步IO。<font color="#c00000">在使用函数实现同步IO时，函数必须在该请求完成后才能返回</font>。
- <font color="#9bbb59">异步</font>：在进行一系列请求时，<font color="#c00000">可以不按照顺序</font>，<font color="#c00000">同时处理多个请求</font>的IO模型叫作异步IO。<font color="#c00000">使用函数实现异步IO时，函数可以在请求完成前就返回</font>(然后通过查询或回调等方式获取或通知结果)。

同步和阻塞之间的关系：
1. <font color="#c00000">阻塞IO一定是同步IO</font>：当应用程序执行阻塞IO时，它会同步地等待IO操作的完成。因此所有阻塞IO操作也是同步的。
2. <font color="#c00000">同步IO</font><span style="background:#fff88f"><font color="#c00000">不一定</font></span><font color="#c00000">是阻塞IO</font>：同步IO表示应用程序关心IO操作何时完成，并在操作完成前不会继续执行其他逻辑处理。<font color="#c00000">但是这并不意味着它一定会阻塞应用程序的执行线程</font>。

### 3.1 阻塞IO(BIO)

以常见的TCP编程为例，其BIO下的通信流程如下图所示：
	![[Pasted image 20241116230432.png]]
在上图中：
- `accept` 、 `read` 、 `write` 均是阻塞型IO：
	- 使用 `accept` 等待客户端的连接时，需要为每一个客户端单独创建一个线程，随后会阻塞在 `accept` 系统调用中，直到有新的客户端连接到达。
	- 使用 `read` 、 `write` 函数进行读写数据操作时，该线程会阻塞到该系统调用，直到读取/写入请求完成。

设想一个场景：
- 在一个8个逻辑CPU的平台上
- 需要同时处理数百个客户端的连接与请求
则此时只能通过在操作系统中建立数百个接收线程阻塞在 `accept` 系统调用中等待客户端连接才可以完成此并发需求。但是这么多的线程必然会导致调度和上下文切换所带来的效率问题。

### 3.2 (同步)非阻塞IO(NIO)

正如上文所述，非阻塞型IO应当有如下特性：
- 该IO的打开、读写等操作一定是非阻塞的。
- 但是若干IO之间依旧需要顺序执行。

针对上述BIO线程数过多的问题，Linux




