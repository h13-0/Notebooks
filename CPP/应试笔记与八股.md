---
number headings: auto, first-level 2, max 6, 1.1
---
#C-Language #应试笔记与八股
```toc

```

## 1 八股简答题和思考题

### 1.1 C语言的优缺点




### 1.2 声明和定义的区别


### 1.3 讲一讲编译和链接



Windows平台下：

Linux平台下：


以及静态链接、动态链接的优缺点(操作系统知识)

### 1.4 讲一讲运算符及其运算顺序

基本规则：
- <font color="#9bbb59">优先级</font>：高优先级先运算，低优先级后运算
- <font color="#9bbb59">结合方向</font>：同优先级若干运算符之间的结合的方向顺序

优先级表：
![[Pasted image 20240302155918.png]]

例如给定式：
```C
int a = 7 + 8 * 5 - 6;
```
式中有运算：
- 二元加减法，优先级4
- 二元乘除法，优先级3
则应当先计算乘法，有：
```C
int a = 7 + 8 * 5 - 6;
      = 7 + 40 - 6；
```
随后看同级运算中的结合顺序，加减法的结合顺序为从左至右，即：
```C
int a = 7 + 8 * 5 - 6;
      = 7 + 40 - 6；
      = (7 + 40) - 6;
```

同理可计算如下式：
```C
int i = 3;
int k = (i++)+(i++)+(i++);
      = (3)+(4)+(5);
      = 12;
```

### 1.5 整数除法是什么计算原则？

即"向零截断"原则，"truncation toward zero"。
例如：
```C
#include <stdio.h>
int main() {
	printf("%d\r\n", 5/3);  // 5/3=1.6667  => 1
	printf("%d\r\n", -5/3); // -5/3=-1.667 => -1
	printf("%d\r\n", -1/3); // -1/3=-0.333 => 0
}
```

### 1.6 负数取余规则

1. <font color="#c00000">运算结果正负号与被除数符号一致</font>。
2. <u>负数间取余的结果</u>的<font color="#c00000">绝对值</font>等于各数<font color="#c00000">绝对值之间取余</font>。
```C
#include <stdio.h>
int main() {
    printf("%d\r\n", 8%3);  //2；被除数为正，绝对值取余为2
    printf("%d\r\n", 8%-3); //2；被除数为正，绝对值取余为2
    printf("%d\r\n", -8%3); //-2；被除数为负，绝对值取余为2
	printf("%d\r\n", -8%-3);//-2；被除数为负，绝对值取余为2
}
```

### 1.7 数字的格式化输出

主要在于整数的 `%xd` 和浮点数的 `%x.xf` 。
对于整数：
```C
#include <stdio.h>
int main() {
	int a = 123, b = 123456;
	printf("%5d\n", a);  // 默认右对齐，且最少取5位整数，多余5位全取，不足5位使用空格左补全
	printf("%05d\n", a); // 使用0代替空格，在左边补齐位数
	printf("%-5d\n", a); // 左对齐，不足位数，使用空格补全
	printf("%-05d\n", a);// 左对齐，不足位数，还是用空格补全
	printf("%5d\n", b);	 // 超过5位全取
}
```
输出结果：
```Shell
  123#为 123 的%5d输出结果，补齐5位、右对齐(默认)、空格补全(默认)
00123#为 123 的%05d输出结果，补齐5位、右对齐(默认)、'0'补全
123  #为 123 的%-5d输出结果，补齐5位、左对齐、空格补全(默认)
123  #为 123 的%-05d输出结果，补齐5位、左对齐，依旧是空格补全
123456#当数据大于5位时全取。
```

对于浮点数：
```C
#include <stdio.h>
int main() {
	double a = 123.326, b = 90.12;
	printf("%.2f\n", a);   // 保留2位小数，第三位四舍五入
	printf("%.3f\n", b);   // 保留3位小数，不足的用0补全
	printf("%3.2f\n", b);  // 输出至少3位字符和2位小数，总输出位数可以大于3，小数点占1位
	printf("%7.2f\n", b);  // 输出至少7位字符和2位小数，总输出位数可以大于7，右对齐
	printf("%-7.2f\n", b); // 输出至少7位字符和2位小数，总输出位数可以大于7，左对齐
}
```
输出：
```Shell
123.33#123.326 的 "%.2f"   输出，保留2位小数
90.120#90.12   的 "%.3f"   输出，保留3位小数，不足的用0补全
90.12# 90.12   的 "%3.2f"  输出，输出至少3位字符和2位小数，总输出位数可以大于3，小数点占1位
  90.12#90.12  的 "%7.2f"  输出
90.12  #90.12  的 "%-7.2f" 输出，左对齐

```

<font color="#c00000">注意</font>：
1. 浮点数输出格式为： `%${控制位}${最小字符长度}.${小数位数}f` 
2. 浮点数输出时，<span style="background:#fff88f"><font color="#c00000">小数点占1位</font></span>。
3. 整数输出格式为： `%${控制位}${补全位}${字符最短长度}d`


### 1.8 讲一下scanf的使用方法

1. `scanf` 的使用方法和 `printf` 的 `format` 不完全相同，
2. 
```C
#include<stdio.h>
int main()
{
	char str[100] = { 0x00 };
 
//	scanf("%[^!]", str);//以!结束输入		注：记得清理缓冲区中剩余字符
//	scanf("%[^\n]",str);//以回车结束输入	注：。。。
//
//	scanf("%[123]",str);	//只能输入123，遇到其他字符后停止匹配
//	scanf("%[^123]",str);	//只能输入非123,遇到其123后停止匹配
//	
//	scanf("%[a-z,A-Z]", str);	//只能输入英文字符，遇到其他字符后停止匹配
//	scanf("%[^a-z,A-Z]",str);	//只能输入非英文字符，遇到其他字符后停止匹配
//
//	scanf("%*c",str);//清理缓冲区中第一个字符，比如：上次遗留下的\n 
//	scanf("%*[^!] %*c",str); //跳过一行 
 
	printf("%s", str);
	return 0;
}
```


### 1.9 讲一下scanf的工作方法








### 1.10 讲一讲strcat




### 1.11 讲一讲Makefile



### 1.12 讲一讲什么是do语句


### 1.13 讲一讲常用的三种退出循环的方式

break、continue、goto的区别


### 1.14 C语言标识符(Identifiers)规则

1. C语言标识符必须以字母 `a-z` 或字母 `A-Z` 或下划线 `_` 开头，后面可以接任意个字母、数字、下划线。<font color="#c00000">不可以数字开头</font>。
2. 标识符区分大小写字母。
3. C89规定标识符的长度在31字符以内，C99规定在63个字符以内，C11对标识符长度无限制。
4. C语言中的关键字不可做为标识符(见C11标准附录A.1.2)

C11标注参考：
	[[C标准学习笔记#6 4 2 标识符 Identifiers]]


### 1.15 对数组使用sizeof会得到什么结果

1. <font color="#c00000">在同一函数内定义的数组的</font> `sizeof` <font color="#c00000">为该数组的实际内存大小</font>，即使是不定长数组(VLA)也是如此：(因此 `sizeof` <font color="#c00000">不一定是预处理时求值</font>(但是开优化后一般直接生成表达式))
```C
#include <stdlib.h>

size_t vla_test(int size)
{
	int array[size];
	return sizeof(array);
}

int main()
{
    printf("%lld", vla_test(89)); //356，4Byte per `int`
    return 0;
}
```
2. <font color="#c00000">但是在不同的函数间定义的数组的</font> `sizeof` <font color="#c00000">运算结果仅为指针大小</font>。
```C
#include <stdio.h>

void array_test(int array[])
{
	printf("sizeof array: %lld\r\n", sizeof(array)); //8
}

int main()
{
    int array[16] = { 0 };
    array_test(array);
    return 0;
}
```

```C
#include <stdio.h>

int array[16] = { 0 };

void array_test()
{
	printf("sizeof array: %lld\r\n", sizeof(array)); //64
}

int main()
{
    array_test();
    return 0;
}
```
因此在处理数组的函数传参时，一定要传两个参数，一个是数组(或指针)，一个是大小。(可以考虑使用宏函数自动处理 `sizeof` )

C11规范见：
	[[C标准学习笔记#6 5 3 4 sizeof和_Alignof运算符]]

### 1.16 Const & Pointer

`const` 优先修饰其左边的描述符，因此有以下几种情况：

| 区别  | `const int* p` | `int* const p` |
| --- | -------------- | -------------- |
|     |                |                |

### 1.17 指针是如何传参的

指针在实际传参时是按照指针传参的，并不关心数组是否匹配，如下：
```C
#include <stdio.h>

void array_test(int array[32])
{
    printf("value of array: %lld\r\n", array);        //140722025083408(Address of `array`)
	printf("sizeof array: %lld\r\n", sizeof(array));  //sizeof(int*)
}

int main()
{
    int array[16] = { 0 };
    array_test(array);                                //哪怕int [16]也可以传进int [32]中
    return 0;
}
```

### 1.18 Array VS Pointer

| <center>区别</center> | <center>int a[size]</center>                                                               | <center>int *a</center>                                      |
| ------------------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存分配                | 定义时即分配                                                                                     | 需要手动分配                                                       |
| 内存回收                | 自动回收                                                                                       | 需要手动回收                                                       |
| 内存置0                | 定义时可直接置0，例如：<br>`int array[32] = { 0 };`<br>但是不可用于置其他数值，见：<br>[[应试笔记与八股#1 15 讲一讲一维数组的初始化]] | 申请时使用 `calloc` 、<br>或申请后使用 `memset`                          |
| `sizeof` 运算         | 不同函数内定义的数组(经过传参的)的sizeof运算结果为指针，<br>直接访问的是实际内存大小，见：<br>[[应试笔记与八股#1 3 对数组使用sizeof会得到什么结果]]  | 一定是指针大小                                                      |
| `a` 是否可变            | 不可变，为常量                                                                                    | 可变，为变量，仅指向内存地址                                               |
| 指向内容                | 必定为数组对应的数据类型                                                                               | 可以指向任意类型的内存区域                                                |
| 函数传参                | 数组在传递时只传递了指针，和指针传参无本质区别。<br>见：[[应试笔记与八股#1 5 指针是如何传参的]]                                     |                                                              |
| 隐式变换                | <font color="#c00000">允许</font> `int *p = a; //a为int a[size]`                              | 但是<font color="#c00000">不允许</font> `int a[] = p; //p为int *p` |
| 访问方式                | <font color="#c00000">允许</font> `*(a + offset)` 访问                                         | 但是<font color="#c00000">不允许</font>指针 `a[offset]` 访问          |


### 1.19 讲一讲一维数组的初始化

1. 一维数组在指定元素数值后，可以不指定大小
```C
int a[] = { 1, 2, 3, 4, 5};
```
2. 一位数组指定元素值时，<font color="#c00000">若指定的元素数量比数组大小小，则剩下元素均会被初始化为0</font>。
```C
int a[32] = { 0 }; //a中所有元素均为0
int b[32] = { 1 }; //b中第一个元素为1，后续均为0
```
3. 使用字符串初始化char数组时，字符串会存储到常量区，<span style="background:#fff88f"><font color="#c00000">因此不可进行修改</font></span>，只可进行读取。
```C
char *p = "abc";
```
4. 若初始化数组的数量大于数组大小，
```C
int a[2] = { 1, 2, 3 };
```

参见[[C标准学习笔记#6 7 9 初始化]]

### 1.20 多维数组怎么初始化


### 1.21 定义常量有哪些合法的方式(十六进制、科学计数法等)

1. 整数型支持：
	- 八进制：<span style="background:#fff88f"><font color="#c00000">以 <code>0</code> 开头</font></span>，例如 `077` 、八进制，值为十进制的
	- 十进制：
	- 十六进制：
1. 




### 1.22 实参和虚参的区别


### 1.23 print函数和puts函数的区别



### 1.24 讲一讲malloc、realloc、calloc的区别和用法


### 1.25 讲一讲存储类型(auto、static、extern、register)




### 1.26 讲一讲什么是异或


### 1.27 C语言中整数隐式转换规则

例如




### 1.28 内存对齐问题

