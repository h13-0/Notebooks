与其说是笔记，更不如说是按照原标准文档的翻译转述。
```toc
title: 目录
min_depth: 1
```

# 5 环境

## 5.1 概念模型

### 5.1.1 翻译环境

#### 5.1.1.1 程序结构

储存有程序代码的文本被称为源文件(或预处理文件)，一个源文件和他使用`#include`包含的所有其他源文件和头文件被统一称作一个 #预处理单元 ，预处理之后的单元叫做 #翻译单元 。
程序的独立翻译单元之间可以使用以下方式进行通信：
1. 调用具有外部链接标识符的函数
2. 操作具有外部链接标识符的对象
3. 操作文件

各个翻译单元之间可以独立翻译，然后最后链接到一起。

#### 5.1.1.2 翻译阶段

翻译阶段的顺序如下：
1. 如果需要，物理源文件将会在行位添加一个新的换行符。???
2. 删除紧跟着换行符的反斜杠字符 `\` ，将物理源行拼成逻辑源行。只有物理源行的最后一个 `\` 才有资格被这样处理。任何非空的源文件应以换行符结尾，否则其前不应紧跟反斜杠字符 `\`
3. 源文件被分解为预处理`token`和空白字符序列(如注释)，源文件不得以不完整的预处理标记或注释结尾，每一个注释会被一个空格取代(**所以反斜杠后面不能接注释**)，换行字符会被保留。TODO:Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character is implementation-defined
4. 执行预处理指令，展开宏调用，并且执行`_Pragama`一元运算符表达式。如果在`token`连接中生成了与通用字符名语法匹配的字符序列，则其行为是未定义的，如[[#6.10.3.3]]中的`##`运算符。使用`#include`预处理指令会递归的处理步骤1到4。
5. 每一个设置了字符和转义字符串的字符常量和字符串会被计算或拼接为正确的值，若没有对应的成员则将会被转移成空字符????
6. 连接相邻的字符串标记，如 `"ab" "cd"` -> `"abcd"`
7. 此时空白字符不再有效，每一个预处理`token`都讲被转化为一个`token`，生成的`tokens`将会被用于语法和语义分析，并作为翻译单元进行翻译
8. 解析所有的外部对象和函数引用，并链接成一个文件


#### 5.1.1.3

### 5.1.2 运行环境

运行环境有以下两种：
- 独立环境(freestanding)
- 托管环境(hosted)

无论在哪种环境下，C程序都会被环境调用。在C程序启动之前，所有的静态储存类型[^1]都会被初始化[^2]并设定为初始值。这种初始化的方式和时间均未具体规定，程序终止后控制权将返回到运行环境。

**引用**
[^1]: 静态储存环境
	[[C标准笔记#6.7.1 储存类型说明符]]
[^2]: 初始化
	[[#6.7.9]]

#### 5.1.2.1 独立环境

#### 5.1.2.2 托管环境

##### 5.1.2.2.1 托管环境下的程序启动

程序启动时所被调用的函数为`main`，其声明可以是：
```C
int main(void)
```
或：
```C
int main(int argc, char *argv[])
```
或上一形式的等效形式：
```C
int main(int argc, char **argv)
```
或其他类型的由托管环境锁指定的声明。
参数的名字并不重要，但为了方便起见以上述命名进行表述：

当这些参数被声明后，这些参数有如下的限制：
1. `argc`的值应为非负
2. `argv[argc]`的值应为空指针`NULL`
3. 如果`argc`的值不为零，则`argv[0]`到`argv[argc - 1]`的值都应指向字符串。这些字符串由托管环境所指定，其目的是获取或传递信息。如果主机环境无法提供大写形式的字符串，则`main`程序在接收的时候应确保其能接收小写形式的字符串。
4. 如果`argc`的值大于0，则`argc[0]`指向的字符串应表示程序名


[\_Pragama with msvc](https://learn.microsoft.com/zh-cn/cpp/preprocessor/pragma-directives-and-the-pragma-keyword)

# 6 语言

## 6.2 概念
### 6.2.2

### 6.2.4

## 6.4 词法元素

### 6.4.4 常量(Constants)

常量类型主要有
- 整数常数
- 浮点常数
- 枚举常数
- 还没看懂

限制：
每一个常量类型都应具有类型，并且其值应在对应类型的可表示范围之内。

#### 6.4.4.1 整数

注意本文所述均为整数常量的定义、而非整数变量的运算。

对于整形常量、可以用前缀定义其进制，后缀定义其类型。

整数常量主要有以下几种类型：
- 十进制(decimal)
- 八进制(octal)
- 十六进制(hexadecimal)

十进制常量整数类型直接定义即可

八进制常量整数类型定义时应带前缀`0`，例如：
```C
int dec = 10;  //等于十进制的10
int oct = 010; //等于十进制的8
```

十六进制常量整数类型定义时应带前缀`0x`，例如：
```C
int hex = 0x10; //等于10进制的16
```

整数常量类型的修饰后缀：
- unsigned后缀
- long后缀
- long-long后缀

unsigned后缀可以为：
\	`u` 或者 `U`

long后缀可以为：
\	`l` 或者 `L`

long-long后缀可以为：
\	`ll` 或者 `LL`


#### 6.4.4.3 枚举(enum)

对于枚举类型的常量，其标识符的类型为`int`

## 6.7 声明

### 6.7.1 储存类型说明符

**语义**
储存类型说明符主要有以下几种：
- typedef
- extern
- static
- \_Thread_local
- auto
- register

**限制**
1. 除了之外`_Thread_local`可以和`static`、`extern`联合使用以外，一个变量最多使用一个储存类型说明符。
2. 在具有块(block)范围的对象的声明中，如果使用了`_Thread_local`则他还应包含`static`或`extern`。TODO: If `_Thread_local` appears in any declaration of an object, it shall be present in every declaration of that object.
3. `_Thread_local`不应该出现在函数声明中的说明符中。
4. `typedef`被称为储存类型说明符只是为了语法方便，这一特性在章节[[#6.7.8]]中有所讨论，TODO:且在[[#6.2.2]]和[[#6.2.4]]中讨论了各种联系以及储存周期的含义。
5. 带有`register`的说明符建议使用在需要尽可能快的访问对象的地方。当然编译器可以不听你的。
6. 具有块作用域的函数声明中不应具有除`extern`以外的显示的储存类型说明符。
7. 如果使用`typedef`以外的储存类型说明符来说明`struct`和`union`对象，则储存说明符所产生的属性也将作用于除链接(TODO:linkage?)以外的成员。

### 6.7.2 变量类型说明符

**语义**
变量类型说明符主要有以下几种：
- void
- char
- short
- int
- long
- float
- double
- signed
- unsigned
- \_Bool
- \_Complex
- 原子类型说明符
- `struct`或`union`所定义的说明符
- `enum`所定义的说明符
- `typedef`所定义的说明符

### 6.7.4 函数说明符

**语义**
函数说明符主要有以下两种：
- `inline`
- `_Noreturn_`

**限制**
1. 函数说明符只能用于函数的声明中(而非定义)。
2. TODO
3. 在托管(TODO:host?)环境中，任何函数说明符不应出现在`main`函数中。
4. 一个函数可以使用多个函数说明符，且说明符之间的行为不受影响。
5. `inline`修饰符建议编译器将其编译为内联干啥，主要用于尽可能快的调用该函数。当然编译器可以不听你的。
6. 内联函数有以下限制：
	1. 如果使用`inline`修饰一个函数的声明，则其应被定义在同一个翻译单元中(也就是源文件必须include其头文件，且由于该特性，内联函数可以多次被定义???)
	2. 如果inline...看不懂了TODO
7. 使用了`_Noreturn_`的函数不能返回调用者，若未写明`return`而导致函数执行完毕退出的，其结果是未定义行为，如下例中 `i <= 0` 的情况：
```C
_Noreturn_ void func(int i)
{
	if(i > 0)
	{
		abort();  //OK
	}
	// UB.
}
```


### 6.7.5 字节对齐说明符



### 6.7.8

## 6.10

### 6.10.3
#### 6.10.3.3


## 6.11 C语言未来的发展方向



