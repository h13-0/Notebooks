与其说是笔记，更不如说是按照原标准文档的翻译转述。
```toc
title: 目录
min_depth: 1
```

# 5 环境

## 5.1 概念模型

### 5.1.1 翻译环境

#### 5.1.1.1 程序结构

储存有程序代码的文本被称为源文件(或预处理文件)，一个源文件和他使用`#include`包含的所有其他源文件和头文件被统一称作一个 #预处理单元 ，预处理之后的单元叫做 #翻译单元 。
程序的独立翻译单元之间可以使用以下方式进行通信：
1. 调用具有外部链接标识符的函数
2. 操作具有外部链接标识符的对象
3. 操作文件

各个翻译单元之间可以独立翻译，然后最后链接到一起。

#### 5.1.1.2 翻译阶段

翻译阶段的顺序如下：
1. ..
2. 删除紧跟着换行符的反斜杠字符 `\` ，将物理源行拼成逻辑源行。只有物理源行的最后一个 `\` 才有资格被这样处理。任何非空的源文件应以换行符结尾，否则其前不应紧跟反斜杠字符 `\`
3. 源文件被分解为预处理`token`和空白字符序列(如注释)，源文件不得以不完整的预处理标记或注释结尾，每一个注释会被一个空格取代(**所以反斜杠后面不能接注释**)，换行字符会被保留。TODO:Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character is implementation-defined
4. 执行预处理指令，展开宏调用，并且执行`_Pragama`一元运算符表达式。如果在`token`连接中生成了与通用字符名语法匹配的字符序列，则其行为是未定义的，如[[#6.10.3.3]]中的`##`运算符。使用`#include`预处理指令会递归的处理步骤1到4。
5. 每一个设置了字符和转义字符串的字符常量和字符串会被计算或拼接为正确的值，若


[\_Pragama with msvc](https://learn.microsoft.com/zh-cn/cpp/preprocessor/pragma-directives-and-the-pragma-keyword)

# 6 语言

## 6.2 概念
### 6.2.2

### 6.2.4

## 6.4 词法元素

### 6.4.4 常量(Constants)

常量类型主要有
- 整数常数
- 浮点常数
- 枚举常数
- 还没看懂

限制：
每一个常量类型都应具有类型，并且其值应在对应类型的可表示范围之内。

#### 6.4.4.1 整数

注意本文所述均为整数常量的定义、而非整数变量的运算。

对于整形常量、可以用前缀定义其进制，后缀定义其类型。

整数常量主要有以下几种类型：
- 十进制(decimal)
- 八进制(octal)
- 十六进制(hexadecimal)

十进制常量整数类型直接定义即可

八进制常量整数类型定义时应带前缀`0`，例如：
```C
int dec = 10;  //等于十进制的10
int oct = 010; //等于十进制的8
```

十六进制常量整数类型定义时应带前缀`0x`，例如：
```C
int hex = 0x10; //等于10进制的16
```

整数常量类型的修饰后缀：
- unsigned后缀
- long后缀
- long-long后缀

unsigned后缀可以为：
\	`u` 或者 `U`

long后缀可以为：
\	`l` 或者 `L`

long-long后缀可以为：
\	`ll` 或者 `LL`


#### 6.4.4.3 枚举(enum)

对于枚举类型的常量，其标识符的类型为`int`

## 6.7 声明

### 6.7.1 储存类型说明符

**语义**
储存类型说明符主要有以下几种：
- typedef
- extern
- static
- \_Thread_local
- auto
- register

**限制**
1. 除了之外`_Thread_local`可以和`static`、`extern`联合使用以外，一个变量最多使用一个储存类型说明符。
2. 在具有块(block)范围的对象的声明中，如果使用了`_Thread_local`则他还应包含`static`或`extern`。TODO: If `_Thread_local` appears in any declaration of an object, it shall be present in every declaration of that object.
3. `_Thread_local`不应该出现在函数声明中的说明符中。
4. `typedef`被称为储存类型说明符只是为了语法方便，这一特性在章节[[#6.7.8]]中有所讨论，TODO:且在[[#6.2.2]]和[[#6.2.4]]中讨论了各种联系以及储存周期的含义。
5. 带有`register`的说明符建议使用在需要尽可能快的访问对象的地方。当然编译器可以不听你的。
6. 具有块作用域的函数声明中不应具有除`extern`以外的显示的储存类型说明符。
7. 如果使用`typedef`以外的储存类型说明符来说明`struct`和`union`对象，则储存说明符所产生的属性也将作用于除链接(TODO:linkage?)以外的成员。

### 6.7.2 变量类型说明符

**语义**
变量类型说明符主要有以下几种：
- void
- char
- short
- int
- long
- float
- double
- signed
- unsigned
- \_Bool
- \_Complex
- 原子类型说明符
- `struct`或`union`所定义的说明符
- `enum`所定义的说明符
- `typedef`所定义的说明符

### 6.7.4 函数说明符

**语义**
函数说明符主要有以下两种：
- `inline`
- `_Noreturn_`

**限制**
1. 函数说明符只能用于函数的声明中(而非定义)。
2. TODO
3. 在托管(TODO:host?)环境中，任何函数说明符不应出现在`main`函数中。
4. 一个函数可以使用多个函数说明符，且说明符之间的行为不受影响。
5. `inline`修饰符建议编译器将其编译为内联干啥，主要用于尽可能快的调用该函数。当然编译器可以不听你的。
6. 内联函数有以下限制：
	1. 如果使用`inline`修饰一个函数的声明，则其应被定义在同一个翻译单元中(也就是源文件必须include其头文件，且由于该特性，内联函数可以多次被定义???)
	2. 如果inline...看不懂了TODO
7. 使用了`_Noreturn_`的函数不能返回调用者，若未写明`return`而导致函数执行完毕退出的，其结果是未定义行为，如下例中 `i <= 0` 的情况：
```C
_Noreturn_ void func(int i)
{
	if(i > 0)
	{
		abort();  //OK
	}
	// UB.
}
```


### 6.7.5 字节对齐说明符



### 6.7.8

## 6.10

### 6.10.3
#### 6.10.3.3


## 6.11 C语言未来的发展方向



