#微型计算机原理与接口技术 #应试笔记与八股 

## 目录

```toc
```

## 1.1 数制及其转换

本章主要讲二进制、十进制、十六进制及其之间互相转换。

## 1.2 计算机中数的表示 ^ney395

计算机中数的表示可以进行如下分类：
- <font color="#9bbb59">定点数</font>：定点数表示法即<font color="#c00000">小数点在数中的位置是固定的</font>，其所固定的位置需要提前约定。可以根据约定的位置不同分为：
	1. 纯整数
		![[Pasted image 20240331200023.png]]
	2. 纯小数
		![[Pasted image 20240331195953.png]]
	3. 整数+小数
		即约定在中间某位的情况。
	优点：
	1. 运算方便
	缺点：
	1. 要求所有原始数据用比例因子化为小数或整数，运算完还需要化回去。
	2. 需要提前约定小数点位置，不同位置之间的定点数计算能处理的范围小，精度低。
- <font color="#9bbb59">浮点数</font>：<font color="#c00000">类似于科学计数法的表示方法</font>，小数点的位置可以移动，且记录于变量内存中

### 1.2.1 定点数的表示方法

定点数又可以分为：
- <font color="#9bbb59">无符号数</font>( `unsigned` )：表示范围为 $0\sim 2^{n-1}$
- <font color="#9bbb59">有符号数</font>，根据符号信息表示的方法可以分为：
	- <font color="#9bbb59">原码</font>：最高位当符号位。
	- <font color="#9bbb59">反码</font>：负数的二进制位表示是对应正数的反码表示。
	- <font color="#9bbb59">补码</font>：找一个"无符号正数"，使得其加减运算性质和这个"有符号负数"一致。
	- <font color="#9bbb59">移码</font>：在补码的基础上，将补码的符号位取反。

#### 1.2.1.1 无符号数的表示方法

对于n位二进制数，则其表示范围为 $[0, 2^{n}-1]$ ，将10进制转化为2进制(16进制)即为计算机中的存储。

#### 1.2.1.2 符号数的表示方法

基本概念：
- <font color="#9bbb59">机器数</font>：一个符号数(包括符号位)在机器中的一组二进制数的表示形式就叫做机器数。
- <font color="#9bbb59">真值</font>：机器数所表示的数值称为该机器数所表示的真值。
具体数值取决于符号数的实现方式，故举例见下方章节。

##### 1.2.1.2.1 原码

尽管当前计算机中实际使用的为补码，但是我们先从原码讲起。

<font color="#c00000">将二进制数最高位当成符号位</font>，正数为 `0` 、负数为 `1` ，其余位数为数值的表示形式即为符号数的原码表示，例如：
- 0110 0100 = +100
- 0111 1111 = +127
- 1110 0100 = -100
- 1111 1111 = -127

则其特性为：
- $n+1$ 位原码能表示的数值范围为 $[-2^{n} + 1, 2^{n} - 1]$ 。
- <span style="background:#fff88f"><font color="#c00000">原码拥有"+0"和"-0"两个"0"</font></span>。

存在的缺陷：
- <font color="#c00000">计算机进行加减运算时需要两套逻辑处理</font>，需要分别实现加法器和减法器，而减法器的硬件实现较为麻烦。
- 少表示一位数。

##### 1.2.1.2.2 反码

对于正数，其反码与原码相同；而<font color="#c00000">对于负数</font>，<font color="#c00000">其二进制表示是其对应正数的反码表示</font>，例如：
- 0110 0100 = +100
- 0111 1111 = +127
则对应的负数为：
- 1001 1011 = -100
- 1000 0000 = -127

则其特性为：
- $n+1$ 位反码能表示的数值范围为 $[-2^{n} + 1, 2^{n} - 1]$ 。
- <span style="background:#fff88f"><font color="#c00000">反码拥有"+0"和"-0"两个"0"</font></span>。

##### 1.2.1.2.3 补码

###### 1.2.1.2.3.1 补码符号数的表示方法

<span style="background:#fff88f"><font color="#c00000">补码是当前计算机使用的符号数表示方法</font></span>。
<span style="background:#fff88f"><font color="#c00000">其核心思想是找一个"无符号正数"，使得其加减运算性质和这个"有符号负数"一致</font></span>。具体规定如下：
1. 正数的补码与其原码一致。
2. 对于负数，其机器数为正数的机器数按位求反再加1(此步骤的+1不溢出到符号位)。
例如：
- +100 = 0110 0100
- +127 = 0111 1111
- -100 = ~(0110 0100) + 1 = 1001 1100
- -127 = ~(0111 1111) + 1 = 1000 0001
- <font color="#c00000">-128 = -127 - 1</font> = 1000 0000

则其特性为：
1. 对于同样的 $n+1$ 位，相较于反码而言，补码可以多表示一个数($-2^n$)：
	1. 对于 $n+1$ 位补码，<font color="#c00000">其能表示的数值范围为</font> $[-2^{n}, 2^{n} - 1]$ 。
	2. 对于 $n$ 位补码，其可以表示 $2^n$ 个不同的数。
2. <span style="background:#fff88f"><font color="#c00000">补码所表示的正负数之间可以直接进行与无符号数规则一致的二进制加法运算</font></span>，<font color="#c00000">并可以保证结果正确</font>。具体可见下一子章节。
	1. 本质为补码涉及时的核心思想(找一个"无符号正数"，使得其加减运算性质和这个"有符号负数"一致)。
3. <font color="#c00000">补码的机器数的数值中</font>，<span style="background:#fff88f"><font color="#c00000">负数的机器数大于正数的机器数</font></span>，<font color="#c00000">因此整数大小比较较为不便</font>(可见移码章节的表格)。

则其优点为：
1. 加减运算只需要使用加法器即可实现，不需要额外的减法器。

存在的缺陷有：
1. <span style="background:#fff88f"><font color="#c00000">负数的机器数大于正数的机器数</font></span>，整数的大小比较不方便。

###### 1.2.1.2.3.2 补码符号数的加、减运算

如上文所述，使用补码原则可保持符号数的加减运算直接按照二进制进行运算，具体举例如下：
1. 普通运算：
	![[Pasted image 20240331171254.png]]
2. 正负数和运算：
	![[Pasted image 20240331171315.png]]
	![[Pasted image 20240331171331.png]]
3. 溢出情况：
	- 向上溢出：
		![[Pasted image 20240331171354.png]]
		此时向上溢出( `OF=1` ，为下一章内容)，$-124=-256+64+68$
	- 向下溢出：
		同样的，对于 `-64-68` ，其结果为：
		`1100 0000` + `1011 1100` = `0111 1100` = `124`
		即： $124 = 256-64-68$

##### 1.2.1.2.4 移码

<font color="#c00000">移码在补码的基础上</font>，<font color="#c00000">将补码的符号位取反</font>，其优点是<span style="background:#fff88f"><font color="#c00000">解决了负数机器数大于正数机器数的问题</font></span>：

|  真值  |     补码      | 补码机器数 |     移码      | 移码机器数 |
| :--: | :---------: | :---: | :---------: | :---: |
| -128 | `1000 0000` |  128  | `0000 0000` |   0   |
| -127 | `1000 0001` |  129  | `0000 0001` |   1   |
| ...  |     ...     |  ...  |     ...     |  ...  |
|  -1  | `1111 1111` |  256  | `0111 1111` |  127  |
|  0   | `0000 0000` |   0   | `1000 0000` |  128  |
|  1   | `0000 0001` |   1   | `1000 0001` |  129  |
| ...  |     ...     |  ...  |     ...     |  ...  |
| 126  | `0111 1110` |  126  | `1111 1110` |  255  |
| 127  | `0111 1111` |  127  | `1111 1111` |  256  |

则其特性为：
- 移码解决了负数机器数大于正数机器数的问题，方便了计算机的数值比较。
- 移码只能用于表示整数。
- 移码所能表示的数值范围与补码相同。

### 1.2.2 定点数相关拓展

#### 1.2.2.1 加法器与减法器


#### 1.2.2.2 C语言及其类型转换





### 1.2.3 浮点数的表示与运算

#### 1.2.3.1 浮点数的表示

一般来说，浮点数的表示格式为：$$N=(-1)^S\times M\times R^E$$






## 1.3 十进制数与字符的编码

### 1.3.1 BCD码 ^aohehj

BCD码就是<span style="background:#fff88f"><font color="#c00000">用四位二进制表示一位十进制</font></span>，且浪费6个字符空间，如下图所示：
	![[Pasted image 20240331172256.png]]
即<span style="background:#fff88f"><font color="#c00000">对于任意n位十进制数，均需要4n位二进制表示</font></span>，例如<font color="#c00000">压缩BCD码</font>：
- 9521 = $(1001\ 0101\ 0010\ 0001)_{BCD}$
- 13.25 = $(0001\ 0011.\ 0010\ 0101)_{BCD}$

而BCD码可以分为压缩BCD码和非压缩BCD码两种：
- 压缩BCD码：一个Byte(8位)用于表示<span style="background:#fff88f"><font color="#c00000">2</font></span>位10进制，例如：
	- 9521 = $(1001\ 0101\ 0010\ 0001)_{BCD}$
- 非压缩BCD码：一个Byte(8位)用于表示<span style="background:#fff88f"><font color="#c00000">1</font></span>位10进制(更浪费了)，例如：
	- 9521 = $(0000\ 1001\ 0000\ 0101\ 0000\ 0010\ 0000\ 0001)_{BCD}$

### 1.3.2 BCD码的运算及其调整

就注意需要对非法BCD码进行进位即可，例如 $9+6$ ：
1. 正常BCD运算
	![[Pasted image 20240331173039.png]]
2. BCD进位调整：
	![[Pasted image 20240331173046.png]]
(不如先用十进制计算，再转BCD)

### 1.3.3 字符编码

字符编码即经典ASCII编码。需要注意的有：
1. 使用符号 `' '` 将字符括起来可以表示该字符的二进制值，例如：
```C
'A'  = 41H
'5C' = 3543H // 注意扩两个字符则是2Byte，且C语言支持扩多个字符
```
2. 由于使用的是经典ASCII表，只有128个表示，故<span style="background:#fff88f"><font color="#c00000">最高位</font></span>可以用于做奇偶校验：
	1. 使用奇校验：操作最高位使得该Byte中 `1` 的数量为奇数个。
	2. 使用偶校验：操作最高位使得该Byte中 `1` 的数量为偶数个。
