#微型计算机原理与接口技术 #应试笔记与八股 

## 目录

```toc
```

## 1.1 数制及其转换

本章主要讲二进制、十进制、十六进制及其之间互相转换。

## 1.2 计算机中数的表示

### 1.2.1 无符号数的表示方法

对于n位二进制数，则其表示范围为 $[0, 2^{n}-1]$ ，将10进制转化为2进制(16进制)即为计算机中的存储。

### 1.2.2 符号数的表示方法

基本概念：
- <font color="#9bbb59">机器数</font>：一个符号数(包括符号位)在机器中的一组二进制数的表示形式就叫做机器数。
- <font color="#9bbb59">真值</font>：机器数所表示的数值称为该机器数所表示的真值。
具体数值取决于符号数的实现方式，故举例见下方章节。

而一个负数通常有三种表示方式，即：
1. 原码
2. 反码
3. 补码
当前计算机中实际使用的为补码，但是我们先从原码讲起。

#### 1.2.2.1 原码

将二进制数最高位当成符号位，正数为 `0` 、负数为 `1` ，其余位数为数值的表示形式即为符号数的原码表示，例如：
- 0110 0100 = +100
- 0111 1111 = +127
- 1110 0100 = -100
- 1111 1111 = -127
则n位原码能表示的数值范围为 $[-2^{n} + 1, 2^{n} - 1]$ ，其拥有 $+0$ 和 $-0$ 两个"0"。其问题是计算机进行加减运算时需要两套逻辑处理，较为麻烦。

则对于上述的 `-127` 为例，其机器数为 `1111 1111` ，真值为 $-127$ 。

#### 1.2.2.2 反码

对于正数，其反码与原码相同；而<font color="#c00000">对于负数</font>，<font color="#c00000">其二进制表示是其对应正数的反码表示</font>，例如：
- 0110 0100 = +100
- 0111 1111 = +127
- 1001 1011 = -100
- 1000 0000 = -127
则n位反码能表示的数值范围为 $[-2^{n} + 1, 2^{n} - 1]$ ，其拥有 $+0$ 和 $-0$ 两个"0"。

#### 1.2.2.3 补码

<span style="background:#fff88f"><font color="#c00000">补码是当前计算机使用的符号数表示方法</font></span>。其核心思想是找一个"无符号正数"，使得其加减运算性质和这个"有符号负数"一致。具体规定如下：
1. 正数的补码与其原码一致。
2. 对于负数，其机器数为正数的机器数按位求反再加1(此步骤的+1不溢出到符号位)。
例如：
- +100 = 0110 0100
- +127 = 0111 1111
- -100 = ~(0110 0100) + 1 = 1001 1100
- -127 = ~(0111 1111) + 1 = 1000 0001
- <font color="#c00000">-128 = -127 - 1</font> = 1000 0000
显然，相较于反码而言，补码可以多表示一个数。对于n位补码，其能表示的数值范围为 $[-2^{n}, 2^{n} - 1]$ ，<font color="#c00000">并且该负数对应的"无符号正数"可以直接和别的正数或负数的"无符号正数"直接二进制加减，并保持所表示的符号数值正确</font>，具体可见下一章节：[[第一章 计算机基础知识#1 2 3 补码符号数的加、减运算]]

### 1.2.3 补码符号数的加、减运算

如上文所说，使用补码原则可保持符号数的加减运算直接按照二进制进行运算，具体举例如下：
1. 普通运算：
	![[Pasted image 20240331171254.png]]
2. 正负数和运算：
	![[Pasted image 20240331171315.png]]
	![[Pasted image 20240331171331.png]]
3. 溢出情况：
	- 向上溢出：
		![[Pasted image 20240331171354.png]]
		此时向上溢出( `OF=1` ，为下一章内容)，$-124=-256+64+68$
	- 向下溢出：
		同样的，对于 `-64-68` ，其结果为：
			`1100 0000` + `1011 1100` = `0111 1100` = `124`
		即： $124 = 256-64-68$

## 1.3 十进制数与字符的编码

### 1.3.1 BCD码 ^aohehj

BCD码就是<span style="background:#fff88f"><font color="#c00000">用四位二进制表示一位十进制</font></span>，且浪费6个字符空间，如下图所示：
	![[Pasted image 20240331172256.png]]
即<span style="background:#fff88f"><font color="#c00000">对于任意n位十进制数，均需要4n位二进制表示</font></span>，例如<font color="#c00000">压缩BCD码</font>：
- 9521 = $(1001\ 0101\ 0010\ 0001)_{BCD}$
- 13.25 = $(0001\ 0011.\ 0010\ 0101)_{BCD}$

而BCD码可以分为压缩BCD码和非压缩BCD码两种：
- 压缩BCD码：一个Byte(8位)用于表示<span style="background:#fff88f"><font color="#c00000">2</font></span>位10进制，例如：
	- 9521 = $(1001\ 0101\ 0010\ 0001)_{BCD}$
- 非压缩BCD码：一个Byte(8位)用于表示<span style="background:#fff88f"><font color="#c00000">1</font></span>位10进制(更浪费了)，例如：
	- 9521 = $(0000\ 1001\ 0000\ 0101\ 0000\ 0010\ 0000\ 0001)_{BCD}$

### 1.3.2 BCD码的运算及其调整

就注意需要对非法BCD码进行进位即可，例如 $9+6$ ：
1. 正常BCD运算
	![[Pasted image 20240331173039.png]]
2. BCD进位调整：
	![[Pasted image 20240331173046.png]]
(不如先用十进制计算，再转BCD)

### 1.3.3 字符编码

字符编码即经典ASCII编码。需要注意的有：
1. 使用符号 `' '` 将字符括起来可以表示该字符的二进制值，例如：
```C
'A'  = 41H
'5C' = 3543H // 注意扩两个字符则是2Byte，且C语言支持扩多个字符
```
2. 由于使用的是经典ASCII表，只有128个表示，故<span style="background:#fff88f"><font color="#c00000">最高位</font></span>可以用于做奇偶校验：
	1. 使用奇校验：操作最高位使得该Byte中 `1` 的数量为奇数个。
	2. 使用偶校验：操作最高位使得该Byte中 `1` 的数量为偶数个。

## 1.4 数的定点数及浮点数

数的定点数和浮点数都是小数的两种表示方法。

### 1.4.1 数的定点数表示

定点数表示法即小数点在数中的位置是固定的，其所固定的位置需要提前约定。可以根据约定的位置不同分为：
1. 纯整数
	![[Pasted image 20240331200023.png]]
2. 纯小数
	![[Pasted image 20240331195953.png]]
3. 整数+小数
	即约定在中间某位的情况。
优点：
1. 运算方便
缺点：
1. 要求所有原始数据用比例因子化为小数或整数，运算完还需要化回去。
2. 需要提前约定小数点位置，不同位置之间的定点数计算能处理的范围小，精度低。

### 1.4.2 数的浮点数表示

浮点数的"浮点"是指小数点的位置是漂浮不定的，其核心是采用科学计数法来表示数字。
其基本原则如下图所示：
	TODO