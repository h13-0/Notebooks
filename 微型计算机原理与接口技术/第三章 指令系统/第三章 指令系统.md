#微型计算机原理与接口技术 #应试笔记与八股 

## 目录

```toc
```

## 3.1 指令格式及其寻址方式

### 3.1.1 指令构成

计算机指令的格式一般为：
	![[Pasted image 20240402205503.png]]
其可以根据操作数的个数分为零地址指令、一地址指令、二地址指令、三地址指令。近代计算机通常使用二地址指令，即两个操作数的指令(当然仍保留有其他操作数的指令，例如 `nop` 指令就是零地址指令)。对于二地址指令，其可能会隐含部分操作数。

### 3.1.2 操作数的类型

操作数可以根据存放的位置分为如下四种：
1. 立即数：存放在指令代码中的操作数就叫做立即数。
2. 寄存器操作数：存放在CPU寄存器中。
3. 存储器操作数：存放在存储器中，这也是绝大多数操作数的存放位置。
4. I/O端口操作数：存放在接口对应的寄存器中。

## 3.2 寻址方式

寻址方式可以根据操作数的获取方式分为如下四种：
1. 立即寻址
2. 寄存器寻址
3. 存储器寻址
4. I/O寻址

### 3.2.1 立即寻址

立即寻址的操作数直接存放于代码段中，和指令一同读写，并按照LSB规则存放。例如 `MOV AX, 1234H` ，则其在内存中的存放结构为：
	![[Pasted image 20240402212343.png]]
<font color="#c00000">该操作数读取不需要占用额外的总线周期</font>。

### 3.2.2 寄存器寻址

寄存器寻址中，<font color="#c00000">操作数存放于寄存器中</font>，例如 `MOV AX, BX` 。<font color="#c00000">该操作也不需要额外的总线周期</font>。

### 3.2.3 存储器寻址

存储器寻址中，<font color="#c00000">操作数存放于内存等存储器中</font>。在8086中是指存放到了内存的数据段、附加段或堆栈段中(反正不在代码段)。

先回忆一下基址寄存器和变址寄存器：
	基址寄存器有 `BX` 、 `BP` 两个，变址寄存器有 `SI` 、 `DI` 两个。
	[[第二章 微处理器与总线#^91p0lh]]

在8086 CPU中，寄存器寻址又可以分为五个小类：
1. 直接寻址：<font color="#c00000">指令中的地址是由代码直接给出的</font>，则此时为直接寻址。
	1. <font color="#c00000">若不指定地址所述的内存段</font>，<font color="#c00000">则默认使用的段为数据段</font> `DS` ，例如：
		- `MOV AX, [1000H]`
	2. <font color="#c00000">若使用了内存段前缀</font>，<font color="#c00000">则以该段寄存器的值为基础进行偏移</font>，例如：
		- `MOV AX, ES:[2000H]`
2. 寄存器间接寻址：<font color="#c00000">指令中的地址存放在了某一寄存器中</font>，且这四个寄存器为 `BX` 、 `BP` 、 `SI` 、 `DI` 之中的一个(<span style="background:#fff88f"><font color="#c00000">不可以为其他寄存器</font></span>)，例如：
	- `MOV AX, [BX/SI/DI]; 将BX中的值作为偏移量，并DS为基址获取操作数`
	- `MOV AX, [BP]; 将BP中的值作为偏移量，并从堆栈段为基址获取操作数`
	注意：
	1. `BX` 、 `SI` 、 `DI` 以 `DS` 为基址； `BP` 以堆栈为基址。<span style="background:#fff88f"><font color="#c00000">只能以这四个寄存器的值为偏移量</font></span>，可能会出改错题。
	2. <font color="#c00000">该方法可以配合段前缀使用</font>，<font color="#c00000">且可以覆盖掉上一条的默认基址</font>，例如：
		- `MOV AX, [BP]; 将BP中的值作为偏移量，并从堆栈段为基址获取操作数`
		- `MOV AX, DS:[BP]; 将BP中的值作为偏移量，并以DS为基址获取操作数`
3. 相对寄存器寻址：<font color="#c00000">在寄存器间接寻址方法的基础上，加上指定偏移量的功能</font>。假设指定的<font color="#c00000">偏移量常数</font>为 `COUNT` ，则有：
	- `MOV AX, COUNT[SI]; 以DS为基址，将SI中的值加上COUNT作为偏移量进行寻址`
	- `MOV AX, [SI + COUNT]; 与上方代码等价`
	`COUNT` 可以是8位也可以是16位的偏移量。
4. 基址变址寻址：<font color="#c00000">由基址寄存器和变址寄存器同时做偏移量进行寻址的方式</font>。例如：
	- `MOV AX, [BX][DI]; 以DS为基址，将BX中的值加上DI中的值作为偏移量进行寻址`
	- `MOV AX, [BP + DI]; 以堆栈为基址，将BX中的值加上DI中的值作为偏移量进行寻址`
	<span style="background:#fff88f"><font color="#c00000">其默认的基址由所使用的基址寄存器来决定</font></span>，使用 `BX` 时，默认以数据段为基址；使用 `BP` 时，默认以堆栈为基址。
	<span style="background:#fff88f"><font color="#c00000">若使用两个基址或两个变址，则指令不合法</font></span>。
5. 相对基址变址寻址：在基址变址寻址的基础上增加一个相对偏移量 `COUNT` 。例如：
	- `MOV AX, COUNT[BX][DI]; 以DS为基址，将BX中的值加上DI中的值再加偏移量作为偏移量进行寻址`
	- `MOV AX, [BP + DI + COUNT]; 以堆栈为基址，将BX中的值加上DI中的值再加偏移量作为偏移量进行寻址`

### 3.2.4 I/O端口寻址

I/O端口的变址方式有两种：
1. 统一变址
2. 独立编制





