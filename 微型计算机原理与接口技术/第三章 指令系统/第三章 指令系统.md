#微型计算机原理与接口技术 #应试笔记与八股 

注：本章节为原书第四章。

## 目录

```toc
```

## 3.1 指令格式及其寻址方式

### 3.1.1 指令构成

计算机指令的格式一般为：
	![[Pasted image 20240402205503.png]]
其可以根据操作数的个数分为零地址指令、一地址指令、二地址指令、三地址指令。近代计算机通常使用二地址指令，即两个操作数的指令(当然仍保留有其他操作数的指令，例如 `nop` 指令就是零地址指令)。对于二地址指令，其可能会隐含部分操作数。

### 3.1.2 操作数的类型

操作数可以根据存放的位置分为如下四种：
1. 立即数：存放在指令代码中的操作数就叫做立即数。
2. 寄存器操作数：存放在CPU寄存器中。
3. 存储器操作数：存放在存储器中，这也是绝大多数操作数的存放位置。
4. I/O端口操作数：存放在接口对应的寄存器中。

## 3.2 寻址方式

寻址方式可以根据操作数的获取方式分为如下四种：
1. 立即寻址
2. 寄存器寻址
3. 存储器寻址
4. I/O寻址

### 3.2.1 立即寻址

立即寻址的操作数直接存放于代码段中，和指令一同读写，并按照LSB规则存放。例如 `MOV AX, 1234H` ，则其在内存中的存放结构为：
	![[Pasted image 20240402212343.png]]
<font color="#c00000">该操作数读取不需要占用额外的总线周期</font>。

### 3.2.2 寄存器寻址

寄存器寻址中，<font color="#c00000">操作数存放于寄存器中</font>，例如 `MOV AX, BX` 。<font color="#c00000">该操作也不需要额外的总线周期</font>。

### 3.2.3 存储器寻址

存储器寻址中，<font color="#c00000">操作数存放于内存等存储器中</font>。在8086中是指存放到了内存的数据段、附加段或堆栈段中(反正不在代码段)。

先回忆一下基址寄存器和变址寄存器：
	基址寄存器有 `BX` 、 `BP` 两个，变址寄存器有 `SI` 、 `DI` 两个。
	[[第二章 微处理器与总线#^91p0lh]]

在8086 CPU中，存储器寻址可以分为五个小类：
1. 直接寻址：<font color="#c00000">指令中的地址是由代码直接给出的</font>，则此时为直接寻址。
	1. <font color="#c00000">若不指定地址所述的内存段</font>，<font color="#c00000">则默认使用的段为数据段</font> `DS` ，例如：
		- `MOV AX, [1000H]`
	2. <font color="#c00000">若使用了内存段前缀</font>，<font color="#c00000">则以该段寄存器的值为基础进行偏移</font>，例如：
		- `MOV AX, ES:[2000H]`
2. 寄存器间接寻址：<font color="#c00000">指令中的地址存放在了某一寄存器中</font>，且这四个寄存器为 `BX` 、 `BP` 、 `SI` 、 `DI` 之中的一个(<span style="background:#fff88f"><font color="#c00000">不可以为其他寄存器</font></span>)，例如：
	- `MOV AX, [BX/SI/DI]; 将BX中的值作为偏移量，并DS为基址获取操作数`
	- `MOV AX, [BP]; 将BP中的值作为偏移量，并从堆栈段为基址获取操作数`
	注意：
	1. `BX` 、 `SI` 、 `DI` 以 `DS` 为基址； `BP` 以堆栈为基址。<span style="background:#fff88f"><font color="#c00000">只能以这四个寄存器的值为偏移量</font></span>，可能会出改错题。
	2. <font color="#c00000">该方法可以配合段前缀使用</font>，<font color="#c00000">且可以覆盖掉上一条的默认基址</font>，例如：
		- `MOV AX, [BP]; 将BP中的值作为偏移量，并从堆栈段为基址获取操作数`
		- `MOV AX, DS:[BP]; 将BP中的值作为偏移量，并以DS为基址获取操作数`
3. 相对寄存器寻址：<font color="#c00000">在寄存器间接寻址方法的基础上，加上指定偏移量的功能</font>。假设指定的<font color="#c00000">偏移量常数</font>为 `COUNT` ，则有：
	- `MOV AX, COUNT[SI]; 以DS为基址，将SI中的值加上COUNT作为偏移量进行寻址`
	- `MOV AX, [SI + COUNT]; 与上方代码等价`
	`COUNT` 可以是8位也可以是16位的偏移量。
4. 基址变址寻址：<font color="#c00000">由基址寄存器和变址寄存器同时做偏移量进行寻址的方式</font>。例如：
	- `MOV AX, [BX][DI]; 以DS为基址，将BX中的值加上DI中的值作为偏移量进行寻址`
	- `MOV AX, [BP + DI]; 以堆栈为基址，将BX中的值加上DI中的值作为偏移量进行寻址`
	<span style="background:#fff88f"><font color="#c00000">其默认的基址由所使用的基址寄存器来决定</font></span>，使用 `BX` 时，默认以数据段为基址；使用 `BP` 时，默认以堆栈为基址。
	<span style="background:#fff88f"><font color="#c00000">若使用两个基址或两个变址，则指令不合法</font></span>。
5. 相对基址变址寻址：在基址变址寻址的基础上增加一个相对偏移量 `COUNT` 。例如：
	- `MOV AX, COUNT[BX][DI]; 以DS为基址，将BX中的值加上DI中的值再加偏移量作为偏移量进行寻址`
	- `MOV AX, [BP + DI + COUNT]; 以堆栈为基址，将BX中的值加上DI中的值再加偏移量作为偏移量进行寻址`

### 3.2.4 I/O端口寻址

I/O端口的<font color="#c00000">编址方式</font>有两种：
1. 统一编址
2. 独立编制(8086/8088采用此方式)

而I/O端口的<font color="#c00000">寻址方式</font>也有两小类：
1. 直接端口寻址
	在使用 `IN` 、 `OUT` 指令进行寻址时，<font color="#c00000">直接使用(8位)立即数提供地址的方式就叫做直接端口寻址</font>。该方法可以寻找256个地址。例如：
	- `IN AX, 63H`
	- `OUT 64H, AX`
2. 间接端口寻址
	在使用 `IN` 、 `OUT` 指令进行寻址时，<font color="#c00000">使用</font> `DX` <font color="#c00000">寄存器(16位)间接给出地址的方式就叫做间接端口寻址</font>。该方法可以寻找64K个地址。例如：
	- `IN AX, DX`
	- `OUT DX, AX`
注：
1. 直接端口寻址<font color="#c00000">只能使用8位地址</font>，寻找256个地址。
2. 间接端口寻址<font color="#c00000">可以使用16为地址</font>，寻找64K个地址。
3. 不可错误的使用中括号(汇编语法问题)： `IN AX, [DX]` 。

随堂练习：
1. 下列寻址方式不正确的是(  )
	A. `[BX][SI]`
	B. `[BP + DI + 25]`
	C. `[BX + BP]`
	D. `[BX + DI]`
<details>
<summary>答案：</summary>
C，需要注意各项的寻址方式：<br>
A项：从数据段寄存器变址寻址<br>
B项：<font color="#c00000">从栈地址寄存器</font>相对基址变址寻址，注意25是16进制数<br>
D项：从数据段寄存器基址变址寻址<br>
</details>

## 3.3 8086/8088指令系统

8086/8088的指令系统按照其功能可以分为六类：
1. 数据传送指令
2. 算术运算指令
3. 逻辑运算指令
4. 串操作指令
5. 程序控制指令
6. CPU控制指令

指令学习时应注意：
	![[Pasted image 20240404160633.png]]

在哈尔滨工程大学的考试中，着重考察以下四种：
1. 数据传送指令
	- `MOV`
	- `PUSH`
	- `POP`
	- `XCHG`
	- `XLAT`
	- `LEA`
	- `IN`
	- `OUT`
2. 算数运算指令
	- ``
3. 逻辑、移位运算指令
3. 控制转移指令

### 3.3.1 数据传送指令

8086/8088 CPU的数据传送指令有：
	![[Pasted image 20240404161010.png]]

#### 3.3.1.1 通用传送指令

##### 3.3.1.1.1 MOV指令

1. 传送指令 `MOV` ，其指令格式为：`MOV DST, SRC` ，将 `SRC` 所指数据传送到 `DST` 。
2. `SRC` 和 `DST` 可以是地址、变量、立即数等。

五个不允许的原则(<font color="#c00000">通常出改错题</font>)：
1. <span style="background:#fff88f"><font color="#c00000">两操作数所指数据位数必须一致</font></span>，不可将16位传送到8位(或反之)，例如 `MOV AH, BX` 或 `MOV [1200H], 10H` (<font color="#c00000">该指令见注1</font>)。
2. <span style="background:#fff88f"><font color="#c00000">两操作数不允许同时为存储器操作数</font></span>，例如 `MOV [BX], [SI]` 或 `MOV [BX], [2000H]`
3. <span style="background:#fff88f"><font color="#c00000">两操作数不允许同时为段寄存器</font></span>，例如 `MOV DS, ES`
4. <span style="background:#fff88f"><font color="#c00000">在源操作数为立即数时，目的操作数不允许为段寄存器</font></span>，例如 `MOV DS, 1000H` ，可以改为两句：
	`MOV AX, 1000H`
	`MOV DS, AX`
5. `IP` <span style="background:#fff88f"><font color="#c00000">和</font></span> `CS` <span style="background:#fff88f"><font color="#c00000">不作为目的操作数</font></span>，例如 `MOV CS, AX` 或 `MOV IP, AX`

注：
1. 可以将 `MOV [1200H], 10H` 改为：
	1. `MOV BYTE PTR [1200H], 10H` ，此时 `[1200H]=10H` 。
	2. `MOV WORD PTR [1200H], 10H` ，此时 `[1200H]=10H` ， `[1201H]=00H` 。

##### 3.3.1.1.2 栈操作指令

1. 8086/8088 CPU拥有一个栈指针寄存器 `SP` ，在任何时候均指向栈顶。
2. 8086/8088 CPU的<font color="#c00000">堆栈从高地址向低地址增长</font>，并且<font color="#c00000">栈内内存存储规则仍为LSB</font>。

入栈指令 `PUSH` ：
1. 格式为 `PUSH SRC` ，将 `SRC` 所指<span style="background:#fff88f"><font color="#c00000">字</font></span>(word)存入栈中。
2. 每次入栈，<span style="background:#fff88f"><font color="#c00000">会使栈指针寄存器</font></span> `SP` $-2$ 。

出栈指令 `POP` ：
1. 格式为 `POP DST` ，将栈顶字存入 `DST` 中。
2. 每次出栈，<span style="background:#fff88f"><font color="#c00000">会使栈指针寄存器</font></span> `SP` $+2$ 。

基本原则：
1. `POP` 操作的<span style="background:#fff88f"><font color="#c00000">源操作数不能是立即数</font></span>。

##### 3.3.1.1.3 交换指令

1. 交换指令的格式为 `XCHG OPR1, OPR2` ，其会交换 `OPR1` 和 `OPR2` 所指数据。
2. 交换指令的<span style="background:#fff88f"><font color="#c00000">两个操作数中至少要有一个是寄存器操作数</font></span>，<font color="#c00000">不可以两个都是存储器操作数</font>。

##### 3.3.1.1.4 换码指令

换码指令又称字节翻译指令，是通过查表来完成代码转换的任务，可以用于做数码管的查表等。
1. 其格式为 `XLAT` 或 `XLAT TABLE` 。
2. 功能为从 `BX` 寄存器或 `TABLE` 所指顶的表格中查找 `AL` 寄存器中的 `index` 对应的值。

例如：
1. 假设表格始地址为 `1300H` ，并连续存放若干数据
	![[Pasted image 20240406200715.png]]
2. 指定 `AL = 0EH` ，指定参数 `TABLE` 或设置 `BX = 1300H`
3. 执行 `XLAT` 或 `XLAT TABLE` 后，该指令会取地址为 `[1300H + 0EH]` 的字节并放入 `AL` 寄存器中，随后 `AL = 06H` ：
	![[Pasted image 20240406200931.png]]

#### 3.3.1.2 目标地址传送指令

##### 3.3.1.2.1 装入有效地址指令

该指令可以理解为对程序中定义的"变量"(即符号地址)取地址并存放到目标寄存器中。
1. 指令格式为 `LEA REG, EA` ，指令名中的 `EA` 表示有效地址。
2. 源操作数 `EA` 一定是一个存储器操作数。
3. 假设符号地址 `TABLE` 指向的地址为 `2800H` ，则指令 `LEA AX, TABLE` 运行完毕后，`AX = 2800H`

#### 3.3.1.3 标志位传送指令

哈工程未讲。

#### 3.3.1.4 I/O数据传送指令

输入指令：
1. 输入指令格式为 `IN AL/AX, PORT`
